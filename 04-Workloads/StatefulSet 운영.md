# StatefulSet Ïö¥ÏòÅ

## üéØ Í∞úÏöî

StatefulSetÏùÄ ÏÉÅÌÉúÎ•º Í∞ÄÏßÑ Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò(Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§, Î©îÏãúÏßÄ ÌÅê, Î∂ÑÏÇ∞ ÏãúÏä§ÌÖú Îì±)ÏùÑ Ïø†Î≤ÑÎÑ§Ìã∞Ïä§ÏóêÏÑú Ïö¥ÏòÅÌïòÍ∏∞ ÏúÑÌïú ÏõåÌÅ¨Î°úÎìú Ïª®Ìä∏Î°§Îü¨ÏûÖÎãàÎã§. Ïò®ÌîÑÎ†ò ÌôòÍ≤ΩÏóêÏÑúÏùò StatefulSet ÏÑ§Í≥Ñ, Î∞∞Ìè¨, Ïö¥ÏòÅ Î∞©Î≤ïÏùÑ Ïã§Ï†Ñ Ï§ëÏã¨ÏúºÎ°ú Îã§Î£πÎãàÎã§.

## üìä StatefulSet vs Deployment

### Ï£ºÏöî Ï∞®Ïù¥Ï†ê

| ÌäπÏÑ± | Deployment | StatefulSet |
|------|------------|-------------|
| **Pod Ïù¥Î¶Ñ** | ÎûúÎç§ | ÏàúÏ∞®Ï†Å (app-0, app-1, app-2) |
| **Pod ÏàúÏÑú** | ÎèôÏãú ÏÉùÏÑ±/ÏÇ≠Ï†ú | ÏàúÏ∞®Ï†Å ÏÉùÏÑ±/ÏÇ≠Ï†ú |
| **ÎÑ§Ìä∏ÏõåÌÅ¨ ID** | ÏûÑÏãú | ÏïàÏ†ïÏ†Å (Headless Service) |
| **Ïä§ÌÜ†Î¶¨ÏßÄ** | Í≥µÏú† Í∞ÄÎä• | Í∞úÎ≥Ñ PVC |
| **ÏóÖÎç∞Ïù¥Ìä∏** | Rolling/Recreate | RollingUpdate/OnDelete |
| **Ïö©ÎèÑ** | Î¨¥ÏÉÅÌÉú Ïï± | ÏÉÅÌÉú Ïú†ÏßÄ Ïï± |

### StatefulSetÏù¥ ÌïÑÏöîÌïú Í≤ΩÏö∞

```yaml
ÏÉÅÌÉúÎ•º Í∞ÄÏßÑ Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò:
  - Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ (MySQL, PostgreSQL, MongoDB)
  - Î©îÏãúÏßÄ ÌÅê (Kafka, RabbitMQ)
  - Î∂ÑÏÇ∞ ÏãúÏä§ÌÖú (Elasticsearch, Cassandra)
  - Ï∫êÏãú ÏãúÏä§ÌÖú (Redis Cluster)

ÏöîÍµ¨ÏÇ¨Ìï≠:
  - ÏïàÏ†ïÏ†ÅÏù∏ ÎÑ§Ìä∏ÏõåÌÅ¨ ID ÌïÑÏöî
  - ÏàúÏ∞®Ï†ÅÏù∏ ÏãúÏûë/Ï¢ÖÎ£å ÌïÑÏöî
  - Í∞úÎ≥Ñ ÏòÅÍµ¨ Ïä§ÌÜ†Î¶¨ÏßÄ ÌïÑÏöî
  - ÌÅ¥Îü¨Ïä§ÌÑ∞ Î©§Î≤ÑÏã≠ Í¥ÄÎ¶¨ ÌïÑÏöî
```

## üóÑÔ∏è Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ StatefulSet

### MySQL ÌÅ¥Îü¨Ïä§ÌÑ∞ Íµ¨ÏÑ±

```yaml
# mysql-statefulset.yaml
---
# Headless Service (ÏïàÏ†ïÏ†ÅÏù∏ ÎÑ§Ìä∏ÏõåÌÅ¨ ID Ï†úÍ≥µ)
apiVersion: v1
kind: Service
metadata:
  name: mysql-headless
  namespace: database
  labels:
    app: mysql
spec:
  clusterIP: None  # Headless Service
  selector:
    app: mysql
  ports:
  - port: 3306
    name: mysql

---
# MySQL StatefulSet
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
  namespace: database
spec:
  serviceName: mysql-headless
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      initContainers:
      # ÏÑúÎ≤Ñ ID ÏÑ§Ï†ï (Pod ÏàúÏÑú Í∏∞Î∞ò)
      - name: init-mysql
        image: mysql:8.0
        command:
        - bash
        - "-c"
        - |
          set -ex
          # Pod ÏàúÏÑúÏóêÏÑú ÏÑúÎ≤Ñ ID Ï∂îÏ∂ú (mysql-0 -> 100, mysql-1 -> 101)
          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1
          ordinal=${BASH_REMATCH[1]}
          echo [mysqld] > /mnt/conf.d/server-id.cnf
          echo server-id=$((100 + $ordinal)) >> /mnt/conf.d/server-id.cnf
          # ÎßàÏä§ÌÑ∞/Ïä¨Î†àÏù¥Î∏å ÏÑ§Ï†ï
          if [[ $ordinal -eq 0 ]]; then
            cp /mnt/config-map/master.cnf /mnt/conf.d/
          else
            cp /mnt/config-map/slave.cnf /mnt/conf.d/
          fi
        volumeMounts:
        - name: conf
          mountPath: /mnt/conf.d
        - name: config-map
          mountPath: /mnt/config-map
      
      # Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÌÅ¥Î°† (Ïä¨Î†àÏù¥Î∏åÏö©)
      - name: clone-mysql
        image: percona/percona-xtrabackup:8.0
        command:
        - bash
        - "-c"
        - |
          set -ex
          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1
          ordinal=${BASH_REMATCH[1]}
          [[ $ordinal -eq 0 ]] && exit 0
          # Ïù¥Ï†Ñ PodÏóêÏÑú Îç∞Ïù¥ÌÑ∞ ÌÅ¥Î°†
          ncat --recv-only mysql-$(($ordinal-1)).mysql-headless 3307 | xbstream -x -C /var/lib/mysql
          xtrabackup --prepare --target-dir=/var/lib/mysql
        volumeMounts:
        - name: data
          mountPath: /var/lib/mysql
          subPath: mysql
        - name: conf
          mountPath: /etc/mysql/conf.d
      
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ALLOW_EMPTY_PASSWORD
          value: "1"
        ports:
        - name: mysql
          containerPort: 3306
        # Î≥ºÎ•® ÎßàÏö¥Ìä∏
        volumeMounts:
        - name: data
          mountPath: /var/lib/mysql
          subPath: mysql
        - name: conf
          mountPath: /etc/mysql/conf.d
        # Î¶¨ÏÜåÏä§ Ï†úÌïú
        resources:
          requests:
            cpu: 500m
            memory: 1Gi
          limits:
            cpu: 1000m
            memory: 2Gi
        # Ìó¨Ïä§Ï≤¥ÌÅ¨
        livenessProbe:
          exec:
            command: ["mysqladmin", "ping"]
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
        readinessProbe:
          exec:
            command: ["mysqladmin", "ping"]
          initialDelaySeconds: 5
          periodSeconds: 2
          timeoutSeconds: 1
      
      # Î∞±ÏóÖ ÏÇ¨Ïù¥ÎìúÏπ¥
      - name: xtrabackup
        image: percona/percona-xtrabackup:8.0
        ports:
        - name: xtrabackup
          containerPort: 3307
        command:
        - bash
        - "-c"
        - |
          set -ex
          cd /var/lib/mysql
          if [[ -f xtrabackup_slave_info && "x$(<xtrabackup_slave_info)" != "x" ]]; then
            cat xtrabackup_slave_info | sed -E 's/;$//g' > change_master_to.sql.in
            rm -f xtrabackup_slave_info xtrabackup_binlog_info
          elif [[ -f xtrabackup_binlog_info ]]; then
            [[ `cat xtrabackup_binlog_info` =~ ^(.*?)[[:space:]]+(.*?)$ ]] || exit 1
            rm -f xtrabackup_binlog_info xtrabackup_slave_info
            echo "CHANGE MASTER TO MASTER_LOG_FILE='${BASH_REMATCH[1]}',\
                  MASTER_LOG_POS=${BASH_REMATCH[2]}" > change_master_to.sql.in
          fi
          if [[ -f change_master_to.sql.in ]]; then
            echo "Waiting for mysqld to be ready..."
            until mysql -h 127.0.0.1 -e "SELECT 1"; do sleep 1; done
            echo "Initializing replication from clone position"
            mysql -h 127.0.0.1 <<EOF
          $(<change_master_to.sql.in),
            MASTER_HOST='mysql-0.mysql-headless',
            MASTER_USER='root',
            MASTER_PASSWORD='',
            MASTER_CONNECT_RETRY=10;
          START SLAVE;
          EOF
          fi
          exec ncat --listen --keep-open --send-only --max-conns=1 3307 -c \
            "xtrabackup --backup --slave-info --stream=xbstream --host=127.0.0.1 --user=root"
        volumeMounts:
        - name: data
          mountPath: /var/lib/mysql
          subPath: mysql
        - name: conf
          mountPath: /etc/mysql/conf.d
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
          limits:
            cpu: 200m
            memory: 200Mi
      
      volumes:
      - name: conf
        emptyDir: {}
      - name: config-map
        configMap:
          name: mysql-config
  
  # PVC ÌÖúÌîåÎ¶ø (Í∞Å PodÎßàÎã§ Í∞úÎ≥Ñ PVC ÏÉùÏÑ±)
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: "fast-ssd"
      resources:
        requests:
          storage: 100Gi

---
# MySQL ÏÑ§Ï†ï ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-config
  namespace: database
data:
  master.cnf: |
    [mysqld]
    log-bin=mysql-bin
    log-slave-updates=1
    binlog-format=ROW
    
  slave.cnf: |
    [mysqld]
    super-read-only=1
    log-slave-updates=1
    read-only=1
```

### MongoDB ReplicaSet

```yaml
# mongodb-statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mongodb
  namespace: database
spec:
  serviceName: mongodb-headless
  replicas: 3
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
    spec:
      containers:
      - name: mongodb
        image: mongo:6.0
        command:
        - mongod
        - "--replSet"
        - "rs0"
        - "--bind_ip_all"
        - "--wiredTigerCacheSizeGB"
        - "1"
        ports:
        - containerPort: 27017
          name: mongodb
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: mongodb-secret
              key: username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mongodb-secret
              key: password
        volumeMounts:
        - name: data
          mountPath: /data/db
        # Ìó¨Ïä§Ï≤¥ÌÅ¨
        livenessProbe:
          exec:
            command:
            - mongosh
            - --eval
            - "db.adminCommand('ping')"
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - mongosh
            - --eval
            - "db.adminCommand('ping')"
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "2Gi"
            cpu: "500m"
          limits:
            memory: "4Gi"
            cpu: "1000m"
      
      # MongoDB ReplicaSet Ï¥àÍ∏∞Ìôî
      initContainers:
      - name: setup-replica-set
        image: mongo:6.0
        command:
        - bash
        - -c
        - |
          if [[ "${HOSTNAME}" == "mongodb-0" ]]; then
            echo "Waiting for MongoDB to start..."
            until mongosh --host mongodb-0.mongodb-headless:27017 --eval "print('waited for connection')"
            do
              sleep 2
            done
            echo "Initializing replica set..."
            mongosh --host mongodb-0.mongodb-headless:27017 <<EOF
            rs.initiate({
              _id: "rs0",
              members: [
                {_id: 0, host: "mongodb-0.mongodb-headless:27017", priority: 2},
                {_id: 1, host: "mongodb-1.mongodb-headless:27017", priority: 1},
                {_id: 2, host: "mongodb-2.mongodb-headless:27017", priority: 1}
              ]
            })
          EOF
          fi
  
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: "fast-ssd"
      resources:
        requests:
          storage: 50Gi

---
apiVersion: v1
kind: Service
metadata:
  name: mongodb-headless
  namespace: database
spec:
  clusterIP: None
  selector:
    app: mongodb
  ports:
  - port: 27017
    name: mongodb
```

## üîÑ StatefulSet ÏóÖÎç∞Ïù¥Ìä∏ Ï†ÑÎûµ

### RollingUpdate ÏÑ§Ï†ï

```yaml
# statefulset-update-strategy.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web-cluster
  namespace: production
spec:
  # ÏóÖÎç∞Ïù¥Ìä∏ Ï†ÑÎûµ
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1      # ÎèôÏãúÏóê ÏóÖÎç∞Ïù¥Ìä∏Ìï† Pod Ïàò
      partition: 0           # ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûëÌï† Pod ÏàúÏÑú (Ïó≠Ïàú)
  
  # Í∏∞Î≥∏ ÏÑ§Ï†ï
  serviceName: web-cluster-headless
  replicas: 5
  selector:
    matchLabels:
      app: web-cluster
  template:
    metadata:
      labels:
        app: web-cluster
    spec:
      containers:
      - name: web-app
        image: myapp:v2.0
        # Pod Í∞Ñ ÏùòÏ°¥ÏÑ±Ïù¥ ÏûàÎäî Í≤ΩÏö∞ ÏàúÏ∞® ÏãúÏûë Î≥¥Ïû•
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
        # Graceful shutdown ÏÑ§Ï†ï
        lifecycle:
          preStop:
            exec:
              command:
              - /bin/sh
              - -c
              - |
                # ÌÅ¥Îü¨Ïä§ÌÑ∞ÏóêÏÑú ÏûêÏã†ÏùÑ Ï†úÍ±∞
                curl -X POST http://localhost:8080/cluster/leave
                sleep 10
      # Ï¢ÖÎ£å ÎåÄÍ∏∞ ÏãúÍ∞Ñ
      terminationGracePeriodSeconds: 60
```

### Canary ÏóÖÎç∞Ïù¥Ìä∏ (Partition ÌôúÏö©)

```bash
#!/bin/bash
# statefulset-canary-update.sh

NAMESPACE="production"
STATEFULSET="web-cluster"
NEW_IMAGE="myapp:v2.0"
TOTAL_REPLICAS=5

echo "Starting StatefulSet canary update..."

# 1. ÏµúÏã† Pod ÌïòÎÇòÎßå ÏóÖÎç∞Ïù¥Ìä∏ (partition ÏÑ§Ï†ï)
kubectl patch statefulset $STATEFULSET -n $NAMESPACE -p '{"spec":{"updateStrategy":{"rollingUpdate":{"partition":'$((TOTAL_REPLICAS-1))'}}}}'

# 2. Ïù¥ÎØ∏ÏßÄ ÏóÖÎç∞Ïù¥Ìä∏
kubectl set image statefulset/$STATEFULSET -n $NAMESPACE web-app=$NEW_IMAGE

# 3. ÎßàÏßÄÎßâ Pod(Í∞ÄÏû• ÎÜíÏùÄ Î≤àÌò∏) ÏóÖÎç∞Ïù¥Ìä∏ ÎåÄÍ∏∞
echo "Updating pod $STATEFULSET-$((TOTAL_REPLICAS-1))..."
kubectl rollout status statefulset/$STATEFULSET -n $NAMESPACE --timeout=300s

# 4. Canary Pod Í≤ÄÏ¶ù
echo "Validating canary pod..."
CANARY_POD="$STATEFULSET-$((TOTAL_REPLICAS-1))"

# Ìó¨Ïä§Ï≤¥ÌÅ¨
if kubectl exec -n $NAMESPACE $CANARY_POD -- curl -f http://localhost:8080/health > /dev/null 2>&1; then
    echo "‚úÖ Canary pod health check passed"
else
    echo "‚ùå Canary pod health check failed"
    exit 1
fi

# 5. ÏÇ¨Ïö©Ïûê ÏäπÏù∏ ÌõÑ Ï†ÑÏ≤¥ ÏóÖÎç∞Ïù¥Ìä∏
read -p "Canary validation successful. Continue with full update? (y/N): " -n 1 -r
echo

if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo "Starting full StatefulSet update..."
    kubectl patch statefulset $STATEFULSET -n $NAMESPACE -p '{"spec":{"updateStrategy":{"rollingUpdate":{"partition":0}}}}'
    kubectl rollout status statefulset/$STATEFULSET -n $NAMESPACE --timeout=600s
    echo "‚úÖ StatefulSet update completed"
else
    echo "Update cancelled. Rolling back canary pod..."
    # PartitionÏùÑ ÏõêÎûòÎåÄÎ°ú ÎêòÎèåÎ¶¨Í≥† Ïù¥Ï†Ñ Ïù¥ÎØ∏ÏßÄÎ°ú Î≥µÏõê
    kubectl patch statefulset $STATEFULSET -n $NAMESPACE -p '{"spec":{"updateStrategy":{"rollingUpdate":{"partition":'$TOTAL_REPLICAS'}}}}'
fi
```

## üîß StatefulSet Ïä§ÏºÄÏùºÎßÅ

### ÏàòÌèâ Ïä§ÏºÄÏùºÎßÅ

```bash
#!/bin/bash
# statefulset-scaling.sh

NAMESPACE="database"
STATEFULSET="mysql"
TARGET_REPLICAS=$1

if [ -z "$TARGET_REPLICAS" ]; then
    echo "Usage: $0 <target-replicas>"
    exit 1
fi

CURRENT_REPLICAS=$(kubectl get statefulset $STATEFULSET -n $NAMESPACE -o jsonpath='{.spec.replicas}')

echo "Scaling $STATEFULSET from $CURRENT_REPLICAS to $TARGET_REPLICAS replicas"

if [ $TARGET_REPLICAS -gt $CURRENT_REPLICAS ]; then
    echo "Scaling UP..."
    kubectl scale statefulset $STATEFULSET -n $NAMESPACE --replicas=$TARGET_REPLICAS
    
    # ÏÉà PodÎì§Ïù¥ Ï§ÄÎπÑÎê† ÎïåÍπåÏßÄ ÎåÄÍ∏∞
    for ((i=$CURRENT_REPLICAS; i<$TARGET_REPLICAS; i++)); do
        echo "Waiting for $STATEFULSET-$i to be ready..."
        kubectl wait --for=condition=ready pod/$STATEFULSET-$i -n $NAMESPACE --timeout=300s
        
        # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÅ¥Îü¨Ïä§ÌÑ∞Ïùò Í≤ΩÏö∞ ÏÉà Î©§Î≤Ñ Ï∂îÍ∞Ä ÏûëÏóÖ
        if [ "$STATEFULSET" = "mysql" ]; then
            echo "Adding $STATEFULSET-$i to MySQL cluster..."
            # MySQL ÌÅ¥Îü¨Ïä§ÌÑ∞ ÏÑ§Ï†ï ÏûëÏóÖ
        fi
    done
    
elif [ $TARGET_REPLICAS -lt $CURRENT_REPLICAS ]; then
    echo "Scaling DOWN..."
    
    # Ïä§ÏºÄÏùº Îã§Ïö¥ Ï†Ñ Îç∞Ïù¥ÌÑ∞ ÏïàÏ†ÑÏÑ± ÌôïÏù∏
    for ((i=$((TARGET_REPLICAS)); i<$CURRENT_REPLICAS; i++)); do
        echo "Preparing to remove $STATEFULSET-$i..."
        
        # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïùò Í≤ΩÏö∞ Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
        if [ "$STATEFULSET" = "mysql" ]; then
            echo "Ensuring data safety for $STATEFULSET-$i..."
            # Î≥µÏ†ú ÏÉÅÌÉú ÌôïÏù∏, Îç∞Ïù¥ÌÑ∞ Î∞±ÏóÖ Îì±
        fi
    done
    
    kubectl scale statefulset $STATEFULSET -n $NAMESPACE --replicas=$TARGET_REPLICAS
    
    echo "‚ö†Ô∏è  Remember to manually clean up PVCs if needed:"
    for ((i=$TARGET_REPLICAS; i<$CURRENT_REPLICAS; i++)); do
        echo "  kubectl delete pvc data-$STATEFULSET-$i -n $NAMESPACE"
    done
fi

echo "‚úÖ Scaling completed"
```

### ÏàòÏßÅ Ïä§ÏºÄÏùºÎßÅ (Î¶¨ÏÜåÏä§ Ï°∞Ï†ï)

```yaml
# statefulset-vertical-scaling.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mongodb
  namespace: database
spec:
  template:
    spec:
      containers:
      - name: mongodb
        image: mongo:6.0
        # Î¶¨ÏÜåÏä§ ÏöîÍµ¨ÏÇ¨Ìï≠ Ï¶ùÍ∞Ä
        resources:
          requests:
            memory: "4Gi"    # 2Gi ‚Üí 4Gi
            cpu: "1000m"     # 500m ‚Üí 1000m
          limits:
            memory: "8Gi"    # 4Gi ‚Üí 8Gi
            cpu: "2000m"     # 1000m ‚Üí 2000m
        # MongoDB ÏÑ§Ï†ïÎèÑ Ìï®Íªò Ï°∞Ï†ï
        command:
        - mongod
        - "--wiredTigerCacheSizeGB"
        - "3"              # Ï∫êÏãú ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä
```

## üíæ StatefulSet Î∞±ÏóÖÍ≥º Î≥µÏõê

### MySQL Î∞±ÏóÖ Ï†ÑÎûµ

```bash
#!/bin/bash
# mysql-backup.sh

NAMESPACE="database"
BACKUP_DIR="/var/backups/mysql"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p "$BACKUP_DIR"

# Í∞Å MySQL Pod Î∞±ÏóÖ
for i in {0..2}; do
    POD_NAME="mysql-$i"
    BACKUP_FILE="$BACKUP_DIR/mysql-$i-backup-$DATE.sql"
    
    echo "Backing up $POD_NAME..."
    
    kubectl exec -n $NAMESPACE $POD_NAME -- mysqldump \
        --all-databases \
        --single-transaction \
        --routines \
        --triggers \
        --master-data=2 > "$BACKUP_FILE"
    
    if [ $? -eq 0 ]; then
        echo "‚úÖ Backup completed: $BACKUP_FILE"
        gzip "$BACKUP_FILE"
    else
        echo "‚ùå Backup failed for $POD_NAME"
    fi
done

# Ïò§ÎûòÎêú Î∞±ÏóÖ Ï†ïÎ¶¨ (30Ïùº Ïù¥ÏÉÅ)
find "$BACKUP_DIR" -name "*.sql.gz" -mtime +30 -delete

echo "MySQL backup completed"
```

### StatefulSet Ïû¨Ìï¥ Î≥µÍµ¨

```bash
#!/bin/bash
# statefulset-disaster-recovery.sh

NAMESPACE="database"
STATEFULSET="mysql"
BACKUP_FILE="/var/backups/mysql/mysql-0-backup-20241201_020000.sql.gz"

echo "Starting StatefulSet disaster recovery..."

# 1. StatefulSet Ïä§ÏºÄÏùº Îã§Ïö¥
echo "Scaling down StatefulSet..."
kubectl scale statefulset $STATEFULSET -n $NAMESPACE --replicas=0

# 2. PVC Îç∞Ïù¥ÌÑ∞ Î∞±ÏóÖ (Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Î≥¥Ï°¥)
echo "Backing up existing PVC data..."
for i in {0..2}; do
    kubectl create job backup-pvc-$i -n $NAMESPACE --image=busybox -- \
        tar czf /backup/pvc-data-$i-$(date +%Y%m%d).tar.gz -C /data .
done

# 3. PVC Ï¥àÍ∏∞Ìôî (ÌïÑÏöîÌïú Í≤ΩÏö∞)
read -p "Delete existing PVC data? (y/N): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    for i in {0..2}; do
        kubectl delete pvc data-$STATEFULSET-$i -n $NAMESPACE
    done
fi

# 4. StatefulSet Ïû¨ÏãúÏûë
echo "Scaling up StatefulSet..."
kubectl scale statefulset $STATEFULSET -n $NAMESPACE --replicas=3

# 5. Ï≤´ Î≤àÏß∏ Pod Î≥µÏõê
echo "Waiting for mysql-0 to be ready..."
kubectl wait --for=condition=ready pod/mysql-0 -n $NAMESPACE --timeout=300s

echo "Restoring data to mysql-0..."
zcat "$BACKUP_FILE" | kubectl exec -i -n $NAMESPACE mysql-0 -- mysql

# 6. Î≥µÏ†ú Ïû¨ÏÑ§Ï†ï
echo "Setting up replication..."
kubectl exec -n $NAMESPACE mysql-1 -- mysql -e "
STOP SLAVE;
RESET SLAVE ALL;
CHANGE MASTER TO 
  MASTER_HOST='mysql-0.mysql-headless',
  MASTER_USER='root',
  MASTER_PASSWORD='';
START SLAVE;"

kubectl exec -n $NAMESPACE mysql-2 -- mysql -e "
STOP SLAVE;
RESET SLAVE ALL;
CHANGE MASTER TO 
  MASTER_HOST='mysql-0.mysql-headless',
  MASTER_USER='root',
  MASTER_PASSWORD='';
START SLAVE;"

echo "‚úÖ Disaster recovery completed"
```

## üìä StatefulSet Î™®ÎãàÌÑ∞ÎßÅ

### ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ Î©îÌä∏Î¶≠

```yaml
# statefulset-monitoring.yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: statefulset-alerts
  namespace: monitoring
spec:
  groups:
  - name: statefulset.rules
    rules:
    - alert: StatefulSetReplicasMismatch
      expr: kube_statefulset_status_replicas_ready != kube_statefulset_spec_replicas
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "StatefulSet {{ $labels.statefulset }} replica mismatch"
        description: "StatefulSet {{ $labels.statefulset }} has {{ $value }} ready replicas but wants {{ $labels.spec_replicas }}"
        
    - alert: StatefulSetUpdateNotProgressing
      expr: kube_statefulset_status_observed_generation != kube_statefulset_metadata_generation
      for: 15m
      labels:
        severity: warning
      annotations:
        summary: "StatefulSet {{ $labels.statefulset }} update not progressing"
        
    - alert: StatefulSetPodNotReady
      expr: kube_pod_status_ready{condition="false"} * on(pod) group_left(statefulset) kube_pod_info{created_by_kind="StatefulSet"}
      for: 10m
      labels:
        severity: critical
      annotations:
        summary: "StatefulSet pod {{ $labels.pod }} not ready"
```

## üîß StatefulSet Ìä∏Îü¨Î∏îÏäàÌåÖ

### ÏùºÎ∞òÏ†ÅÏù∏ Î¨∏Ï†úÎì§

#### 1. PodÍ∞Ä Pending ÏÉÅÌÉú
```bash
# PVC ÏÉÅÌÉú ÌôïÏù∏
kubectl get pvc -n $NAMESPACE

# Ïä§ÌÜ†Î¶¨ÏßÄ ÌÅ¥ÎûòÏä§ ÌôïÏù∏
kubectl get storageclass

# Ïù¥Î≤§Ìä∏ ÌôïÏù∏
kubectl get events -n $NAMESPACE --sort-by='.lastTimestamp'
```

#### 2. Pod ÏãúÏûë ÏàúÏÑú Î¨∏Ï†ú
```bash
# Pod ÏùòÏ°¥ÏÑ± ÌôïÏù∏
kubectl describe pod $POD_NAME -n $NAMESPACE

# Init Container Î°úÍ∑∏ ÌôïÏù∏
kubectl logs $POD_NAME -c init-container -n $NAMESPACE

# readinessProbe ÏÑ§Ï†ï ÌôïÏù∏
kubectl get pod $POD_NAME -n $NAMESPACE -o yaml | grep -A 10 readinessProbe
```

#### 3. Îç∞Ïù¥ÌÑ∞ ÏÜêÏã§ Î¨∏Ï†ú
```bash
# PV ÏÉÅÌÉú ÌôïÏù∏
kubectl get pv

# Î∞±ÏóÖ Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏
ls -la /var/backups/

# Îç∞Ïù¥ÌÑ∞ Î≥µÍµ¨ Ï†àÏ∞® Ïã§Ìñâ
./statefulset-disaster-recovery.sh
```

---

> üí° **Ïã§Ï†Ñ Í≤ΩÌóò**: StatefulSetÏùÄ ÏÉÅÌÉúÎ•º Í∞ÄÏßÑ Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏùò ÌäπÏÑ±ÏùÑ Ïù¥Ìï¥ÌïòÍ≥† Ïö¥ÏòÅÌï¥Ïïº Ìï©ÎãàÎã§. ÌäπÌûà Îç∞Ïù¥ÌÑ∞ Î∞±ÏóÖ, ÌÅ¥Îü¨Ïä§ÌÑ∞ Î©§Î≤ÑÏã≠ Í¥ÄÎ¶¨, ÏàúÏ∞®Ï†Å ÏóÖÎç∞Ïù¥Ìä∏Ïóê Ïã†Í≤Ω Ïç®Ïïº ÌïòÎ©∞, Ïä§ÏºÄÏùºÎßÅ ÏãúÏóêÎäî Îç∞Ïù¥ÌÑ∞ ÏïàÏ†ÑÏÑ±ÏùÑ ÏµúÏö∞ÏÑ†ÏúºÎ°ú Í≥†Î†§Ìï¥Ïïº Ìï©ÎãàÎã§.

ÌÉúÍ∑∏: #statefulset #database #mysql #mongodb #scaling #backup #recovery