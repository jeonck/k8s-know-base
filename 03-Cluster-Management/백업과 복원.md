# ë°±ì—…ê³¼ ë³µì›

## ğŸ¯ ê°œìš”

ì¿ ë²„ë„¤í‹°ìŠ¤ í´ëŸ¬ìŠ¤í„°ì˜ ì™„ì „í•œ ë°±ì—… ì „ëµê³¼ ì¬í•´ ë³µêµ¬ ì ˆì°¨ë¥¼ ë‹¤ë£¹ë‹ˆë‹¤. etcd ë°±ì—…, ì• í”Œë¦¬ì¼€ì´ì…˜ ë°ì´í„° ë°±ì—…, ì„¤ì • ë°±ì—…ë¶€í„° ì „ì²´ í´ëŸ¬ìŠ¤í„° ë³µì›ê¹Œì§€ì˜ ì‹¤ì „ ê°€ì´ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤.

## ğŸ—‚ï¸ ë°±ì—… ì „ëµ ê°œìš”

### ë°±ì—… ëŒ€ìƒ ë¶„ë¥˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Kubernetes Cluster              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Control Plane Data                          â”‚
â”‚    - etcd (cluster state)                      â”‚
â”‚    - Certificates (/etc/kubernetes/pki)        â”‚
â”‚    - Configuration files                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. Application Data                            â”‚
â”‚    - PersistentVolume data                     â”‚
â”‚    - Database contents                         â”‚
â”‚    - Application files                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3. Configuration & Secrets                     â”‚
â”‚    - ConfigMaps                                â”‚
â”‚    - Secrets                                   â”‚
â”‚    - RBAC policies                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4. Application Definitions                     â”‚
â”‚    - YAML manifests                            â”‚
â”‚    - Helm charts                               â”‚
â”‚    - Custom resources                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ë°±ì—… ìš°ì„ ìˆœìœ„

| ìš°ì„ ìˆœìœ„ | ë°±ì—… ëŒ€ìƒ | ë¹ˆë„ | RTO | RPO |
|----------|-----------|------|-----|-----|
| **Critical** | etcd, ì¸ì¦ì„œ | ë§¤ì¼ | < 1ì‹œê°„ | < 4ì‹œê°„ |
| **High** | ì• í”Œë¦¬ì¼€ì´ì…˜ ë°ì´í„° | ë§¤ì¼ | < 4ì‹œê°„ | < 8ì‹œê°„ |
| **Medium** | ì„¤ì • ë°ì´í„° | ì£¼ê°„ | < 8ì‹œê°„ | < 24ì‹œê°„ |
| **Low** | ì• í”Œë¦¬ì¼€ì´ì…˜ ì •ì˜ | ë³€ê²½ ì‹œ | < 24ì‹œê°„ | ë³€ê²½ ì‹œì  |

## ğŸ”§ etcd ë°±ì—…

### ìë™í™”ëœ etcd ë°±ì—… ì‹œìŠ¤í…œ

```bash
#!/bin/bash
# etcd-backup-system.sh

# ì„¤ì • ë³€ìˆ˜
BACKUP_DIR="/var/backups/etcd"
RETENTION_DAYS=30
BACKUP_PREFIX="etcd-snapshot"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/${BACKUP_PREFIX}-${DATE}.db"

# etcd ì—”ë“œí¬ì¸íŠ¸ ë° ì¸ì¦ì„œ ì„¤ì •
ETCD_ENDPOINTS="https://127.0.0.1:2379"
ETCD_CACERT="/etc/kubernetes/pki/etcd/ca.crt"
ETCD_CERT="/etc/kubernetes/pki/etcd/server.crt"
ETCD_KEY="/etc/kubernetes/pki/etcd/server.key"

# ë¡œê·¸ ì„¤ì •
LOG_FILE="/var/log/etcd-backup.log"
exec > >(tee -a "$LOG_FILE")
exec 2>&1

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# ë°±ì—… ë””ë ‰í† ë¦¬ ìƒì„±
create_backup_directory() {
    if [ ! -d "$BACKUP_DIR" ]; then
        mkdir -p "$BACKUP_DIR"
        log "Created backup directory: $BACKUP_DIR"
    fi
}

# etcd ìƒíƒœ í™•ì¸
check_etcd_health() {
    log "Checking etcd health..."
    
    ETCDCTL_API=3 etcdctl \
        --endpoints="$ETCD_ENDPOINTS" \
        --cacert="$ETCD_CACERT" \
        --cert="$ETCD_CERT" \
        --key="$ETCD_KEY" \
        endpoint health
    
    if [ $? -ne 0 ]; then
        log "ERROR: etcd health check failed"
        exit 1
    fi
    
    log "etcd health check passed"
}

# etcd ë°±ì—… ì‹¤í–‰
create_etcd_backup() {
    log "Starting etcd backup: $BACKUP_FILE"
    
    # ë°±ì—… ìƒì„±
    ETCDCTL_API=3 etcdctl \
        --endpoints="$ETCD_ENDPOINTS" \
        --cacert="$ETCD_CACERT" \
        --cert="$ETCD_CERT" \
        --key="$ETCD_KEY" \
        snapshot save "$BACKUP_FILE"
    
    if [ $? -eq 0 ]; then
        log "etcd backup created successfully: $BACKUP_FILE"
        
        # ë°±ì—… ê²€ì¦
        ETCDCTL_API=3 etcdctl snapshot status "$BACKUP_FILE" --write-out=table
        log "Backup verification completed"
        
        # ì••ì¶•
        gzip "$BACKUP_FILE"
        log "Backup compressed: ${BACKUP_FILE}.gz"
        
        # ê¶Œí•œ ì„¤ì •
        chmod 600 "${BACKUP_FILE}.gz"
        chown root:root "${BACKUP_FILE}.gz"
        
    else
        log "ERROR: etcd backup failed"
        exit 1
    fi
}

# ì¸ì¦ì„œ ë°±ì—…
backup_certificates() {
    log "Backing up Kubernetes certificates..."
    
    local cert_backup_file="$BACKUP_DIR/kubernetes-certs-${DATE}.tar.gz"
    
    tar -czf "$cert_backup_file" -C /etc/kubernetes pki/
    
    if [ $? -eq 0 ]; then
        log "Certificates backed up: $cert_backup_file"
        chmod 600 "$cert_backup_file"
    else
        log "ERROR: Certificate backup failed"
    fi
}

# ì„¤ì • íŒŒì¼ ë°±ì—…
backup_configs() {
    log "Backing up Kubernetes configuration files..."
    
    local config_backup_file="$BACKUP_DIR/kubernetes-configs-${DATE}.tar.gz"
    
    tar -czf "$config_backup_file" \
        -C /etc/kubernetes \
        admin.conf \
        controller-manager.conf \
        kubelet.conf \
        scheduler.conf \
        manifests/ 2>/dev/null || true
    
    if [ $? -eq 0 ]; then
        log "Configuration files backed up: $config_backup_file"
        chmod 600 "$config_backup_file"
    else
        log "WARNING: Some configuration files may not have been backed up"
    fi
}

# ì›ê²© ì €ì¥ì†Œë¡œ ë°±ì—… ë³µì‚¬
upload_to_remote() {
    local remote_server="backup-server.company.local"
    local remote_path="/backups/kubernetes/etcd"
    
    log "Uploading backups to remote server..."
    
    # ìµœì‹  ë°±ì—… íŒŒì¼ë“¤ ì°¾ê¸°
    local latest_files=$(find "$BACKUP_DIR" -name "*${DATE}*" -type f)
    
    for file in $latest_files; do
        if command -v rsync >/dev/null 2>&1; then
            rsync -av "$file" "$remote_server:$remote_path/"
            log "Uploaded: $(basename $file)"
        else
            scp "$file" "$remote_server:$remote_path/"
            log "Uploaded: $(basename $file)"
        fi
    done
}

# ì˜¤ë˜ëœ ë°±ì—… ì •ë¦¬
cleanup_old_backups() {
    log "Cleaning up backups older than $RETENTION_DAYS days..."
    
    # ë¡œì»¬ ë°±ì—… ì •ë¦¬
    find "$BACKUP_DIR" -name "${BACKUP_PREFIX}-*.db.gz" -mtime +$RETENTION_DAYS -delete
    find "$BACKUP_DIR" -name "kubernetes-certs-*.tar.gz" -mtime +$RETENTION_DAYS -delete
    find "$BACKUP_DIR" -name "kubernetes-configs-*.tar.gz" -mtime +$RETENTION_DAYS -delete
    
    log "Old backup cleanup completed"
}

# ë°±ì—… ë¬´ê²°ì„± ê²€ì¦
verify_backup_integrity() {
    log "Verifying backup integrity..."
    
    local latest_backup=$(ls -t "$BACKUP_DIR"/${BACKUP_PREFIX}-*.db.gz | head -1)
    
    if [ -f "$latest_backup" ]; then
        # ì••ì¶• í•´ì œí•˜ì—¬ ê²€ì¦
        local temp_file="/tmp/temp-etcd-verify-$(date +%s).db"
        gunzip -c "$latest_backup" > "$temp_file"
        
        ETCDCTL_API=3 etcdctl snapshot status "$temp_file" --write-out=json | jq '.'
        
        if [ $? -eq 0 ]; then
            log "Backup integrity verification passed"
        else
            log "ERROR: Backup integrity verification failed"
        fi
        
        rm -f "$temp_file"
    else
        log "WARNING: No backup file found for verification"
    fi
}

# ë©”ì¸ ì‹¤í–‰
main() {
    log "=== Starting etcd backup process ==="
    
    create_backup_directory
    check_etcd_health
    create_etcd_backup
    backup_certificates
    backup_configs
    verify_backup_integrity
    
    # ì›ê²© ë°±ì—… (ì„¤ì •ëœ ê²½ìš°)
    if [ "${ENABLE_REMOTE_BACKUP:-false}" = "true" ]; then
        upload_to_remote
    fi
    
    cleanup_old_backups
    
    log "=== etcd backup process completed successfully ==="
}

# ë³µì› ëª¨ë“œ ì²˜ë¦¬
if [ "$1" = "restore" ]; then
    if [ -z "$2" ]; then
        echo "Usage: $0 restore <backup-file>"
        echo "Available backups:"
        ls -la "$BACKUP_DIR"/${BACKUP_PREFIX}-*.db.gz | tail -10
        exit 1
    fi
    
    restore_etcd_backup "$2"
else
    main "$@"
fi

# etcd ë³µì› í•¨ìˆ˜
restore_etcd_backup() {
    local backup_file="$1"
    local restore_dir="/var/lib/etcd-restore"
    
    log "=== Starting etcd restore process ==="
    log "Backup file: $backup_file"
    
    # ë°±ì—… íŒŒì¼ ì¡´ì¬ í™•ì¸
    if [ ! -f "$backup_file" ]; then
        log "ERROR: Backup file not found: $backup_file"
        exit 1
    fi
    
    # ì••ì¶•ëœ ë°±ì—…ì¸ ê²½ìš° ì••ì¶• í•´ì œ
    local restore_file="$backup_file"
    if [[ "$backup_file" == *.gz ]]; then
        restore_file="/tmp/etcd-restore-$(date +%s).db"
        gunzip -c "$backup_file" > "$restore_file"
        log "Decompressed backup file"
    fi
    
    # ê¸°ì¡´ etcd ë°ì´í„° ë°±ì—…
    if [ -d "/var/lib/etcd" ]; then
        mv /var/lib/etcd "/var/lib/etcd-backup-$(date +%s)"
        log "Moved existing etcd data to backup location"
    fi
    
    # etcd ë³µì›
    ETCDCTL_API=3 etcdctl snapshot restore "$restore_file" \
        --data-dir="$restore_dir" \
        --name="default" \
        --initial-cluster="default=https://127.0.0.1:2380" \
        --initial-advertise-peer-urls="https://127.0.0.1:2380"
    
    if [ $? -eq 0 ]; then
        # ë³µì›ëœ ë°ì´í„°ë¥¼ ì˜¬ë°”ë¥¸ ìœ„ì¹˜ë¡œ ì´ë™
        mv "$restore_dir" "/var/lib/etcd"
        chown -R etcd:etcd /var/lib/etcd
        
        log "etcd restore completed successfully"
        log "Please restart the kubelet and etcd services"
        log "systemctl restart kubelet"
        
        # ì„ì‹œ íŒŒì¼ ì •ë¦¬
        if [[ "$backup_file" == *.gz ]]; then
            rm -f "$restore_file"
        fi
    else
        log "ERROR: etcd restore failed"
        exit 1
    fi
}
```

### etcd ë°±ì—… ìë™í™” (Kubernetes CronJob)

```yaml
# etcd-backup-cronjob.yaml
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: etcd-backup-script
  namespace: kube-system
data:
  backup.sh: |
    #!/bin/bash
    
    BACKUP_DIR="/backup"
    DATE=$(date +%Y%m%d_%H%M%S)
    BACKUP_FILE="$BACKUP_DIR/etcd-snapshot-$DATE.db"
    
    # etcd ë°±ì—… ìƒì„±
    ETCDCTL_API=3 etcdctl \
        --endpoints=https://127.0.0.1:2379 \
        --cacert=/etc/kubernetes/pki/etcd/ca.crt \
        --cert=/etc/kubernetes/pki/etcd/server.crt \
        --key=/etc/kubernetes/pki/etcd/server.key \
        snapshot save "$BACKUP_FILE"
    
    # ë°±ì—… ê²€ì¦
    ETCDCTL_API=3 etcdctl snapshot status "$BACKUP_FILE"
    
    # ì••ì¶•
    gzip "$BACKUP_FILE"
    
    echo "Backup completed: ${BACKUP_FILE}.gz"

---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: etcd-backup
  namespace: kube-system
spec:
  schedule: "0 2 * * *"  # ë§¤ì¼ ì˜¤ì „ 2ì‹œ
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        spec:
          tolerations:
          - key: node-role.kubernetes.io/control-plane
            operator: Exists
            effect: NoSchedule
          nodeSelector:
            node-role.kubernetes.io/control-plane: ""
          hostNetwork: true
          containers:
          - name: etcd-backup
            image: k8s.gcr.io/etcd:3.5.6-0
            command: ["/bin/sh"]
            args: ["/scripts/backup.sh"]
            volumeMounts:
            - name: etcd-certs
              mountPath: /etc/kubernetes/pki/etcd
              readOnly: true
            - name: backup-volume
              mountPath: /backup
            - name: script
              mountPath: /scripts
            resources:
              requests:
                cpu: 100m
                memory: 128Mi
              limits:
                cpu: 500m
                memory: 512Mi
          volumes:
          - name: etcd-certs
            hostPath:
              path: /etc/kubernetes/pki/etcd
              type: Directory
          - name: backup-volume
            persistentVolumeClaim:
              claimName: etcd-backup-pvc
          - name: script
            configMap:
              name: etcd-backup-script
              defaultMode: 0755
          restartPolicy: OnFailure

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: etcd-backup-pvc
  namespace: kube-system
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: backup-storage
  resources:
    requests:
      storage: 50Gi
```

## ğŸ’¾ ì• í”Œë¦¬ì¼€ì´ì…˜ ë°ì´í„° ë°±ì—…

### Veleroë¥¼ ì´ìš©í•œ í´ëŸ¬ìŠ¤í„° ë°±ì—…

```bash
#!/bin/bash
# install-velero.sh

# Velero ì„¤ì¹˜ ë° ì„¤ì •
install_velero() {
    echo "Installing Velero..."
    
    # Velero CLI ë‹¤ìš´ë¡œë“œ
    VELERO_VERSION="v1.11.1"
    wget "https://github.com/vmware-tanzu/velero/releases/download/$VELERO_VERSION/velero-$VELERO_VERSION-linux-amd64.tar.gz"
    tar -xzf "velero-$VELERO_VERSION-linux-amd64.tar.gz"
    sudo mv "velero-$VELERO_VERSION-linux-amd64/velero" /usr/local/bin/
    
    # MinIOë¥¼ ë°±ì—… ìŠ¤í† ë¦¬ì§€ë¡œ ì„¤ì •
    kubectl create namespace velero
    
    # MinIO ìê²©ì¦ëª… ìƒì„±
    cat > credentials-velero << EOF
[default]
aws_access_key_id = minio
aws_secret_access_key = minio123
EOF
    
    kubectl create secret generic cloud-credentials \
        --namespace velero \
        --from-file cloud=credentials-velero
    
    # Velero ì„¤ì¹˜ (MinIO ë°±ì—”ë“œ)
    velero install \
        --provider aws \
        --plugins velero/velero-plugin-for-aws:v1.7.1 \
        --bucket velero-backups \
        --secret-file ./credentials-velero \
        --use-volume-snapshots=false \
        --backup-location-config region=minio,s3ForcePathStyle="true",s3Url=http://minio.minio.svc.cluster.local:9000 \
        --use-node-agent
    
    echo "Velero installation completed"
}

# MinIO ìŠ¤í† ë¦¬ì§€ ì„œë²„ ë°°í¬
deploy_minio() {
    echo "Deploying MinIO for backup storage..."
    
    cat << EOF | kubectl apply -f -
apiVersion: v1
kind: Namespace
metadata:
  name: minio

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: minio
  namespace: minio
spec:
  selector:
    matchLabels:
      app: minio
  template:
    metadata:
      labels:
        app: minio
    spec:
      containers:
      - name: minio
        image: minio/minio:latest
        command:
        - /bin/bash
        - -c
        args: 
        - minio server /data --console-address :9001
        env:
        - name: MINIO_ROOT_USER
          value: "minio"
        - name: MINIO_ROOT_PASSWORD
          value: "minio123"
        ports:
        - containerPort: 9000
          name: api
        - containerPort: 9001
          name: console
        volumeMounts:
        - name: storage
          mountPath: /data
      volumes:
      - name: storage
        persistentVolumeClaim:
          claimName: minio-pvc

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: minio-pvc
  namespace: minio
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: backup-storage
  resources:
    requests:
      storage: 100Gi

---
apiVersion: v1
kind: Service
metadata:
  name: minio
  namespace: minio
spec:
  selector:
    app: minio
  ports:
  - port: 9000
    targetPort: 9000
    name: api
  - port: 9001
    targetPort: 9001
    name: console
EOF
    
    echo "MinIO deployment completed"
}

install_velero
deploy_minio
```

### ë°±ì—… ìŠ¤ì¼€ì¤„ ì„¤ì •

```yaml
# velero-backup-schedules.yaml
---
# ì „ì²´ í´ëŸ¬ìŠ¤í„° ì¼ì¼ ë°±ì—…
apiVersion: velero.io/v1
kind: Schedule
metadata:
  name: daily-cluster-backup
  namespace: velero
spec:
  schedule: "0 1 * * *"  # ë§¤ì¼ ì˜¤ì „ 1ì‹œ
  template:
    includedNamespaces:
    - "*"
    excludedNamespaces:
    - kube-system
    - kube-public
    - kube-node-lease
    - velero
    storageLocation: default
    ttl: 720h0m0s  # 30ì¼ ë³´ê´€
    includeClusterResources: true
    snapshotVolumes: true

---
# ìš´ì˜ í™˜ê²½ ë°±ì—… (ë†’ì€ ë¹ˆë„)
apiVersion: velero.io/v1
kind: Schedule
metadata:
  name: production-backup
  namespace: velero
spec:
  schedule: "0 */6 * * *"  # 6ì‹œê°„ë§ˆë‹¤
  template:
    includedNamespaces:
    - production
    storageLocation: default
    ttl: 168h0m0s  # 7ì¼ ë³´ê´€
    includeClusterResources: false
    snapshotVolumes: true
    labelSelector:
      matchLabels:
        backup.company.com/include: "true"

---
# ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… (ë§¤ì‹œê°„)
apiVersion: velero.io/v1
kind: Schedule
metadata:
  name: database-backup
  namespace: velero
spec:
  schedule: "0 * * * *"  # ë§¤ì‹œê°„
  template:
    includedNamespaces:
    - production
    storageLocation: default
    ttl: 72h0m0s  # 3ì¼ ë³´ê´€
    includeClusterResources: false
    snapshotVolumes: true
    labelSelector:
      matchLabels:
        app.kubernetes.io/component: database

---
# ì£¼ê°„ ì „ì²´ ë°±ì—… (ì¥ê¸° ë³´ê´€)
apiVersion: velero.io/v1
kind: Schedule
metadata:
  name: weekly-full-backup
  namespace: velero
spec:
  schedule: "0 3 * * 0"  # ë§¤ì£¼ ì¼ìš”ì¼ ì˜¤ì „ 3ì‹œ
  template:
    includedNamespaces:
    - "*"
    storageLocation: default
    ttl: 8760h0m0s  # 1ë…„ ë³´ê´€
    includeClusterResources: true
    snapshotVolumes: true
```

### ì• í”Œë¦¬ì¼€ì´ì…˜ë³„ ë°±ì—… ì „ëµ

```yaml
# application-backup-annotations.yaml
---
# ë°ì´í„°ë² ì´ìŠ¤ Pod - Pre/Post í›… ì„¤ì •
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: production
  annotations:
    backup.company.com/include: "true"
    backup.company.com/strategy: "database"
spec:
  template:
    metadata:
      annotations:
        # Velero ë°±ì—… í›…
        pre.hook.backup.velero.io/command: '["/bin/bash", "-c", "mysqldump --single-transaction --routines --triggers -u root -p$MYSQL_ROOT_PASSWORD --all-databases > /backup/mysql-dump.sql"]'
        pre.hook.backup.velero.io/timeout: "3m"
        post.hook.backup.velero.io/command: '["/bin/bash", "-c", "rm -f /backup/mysql-dump.sql"]'
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: password
        volumeMounts:
        - name: mysql-data
          mountPath: /var/lib/mysql
        - name: backup-temp
          mountPath: /backup
      volumes:
      - name: mysql-data
        persistentVolumeClaim:
          claimName: mysql-pvc
      - name: backup-temp
        emptyDir: {}

---
# ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ - ìƒíƒœ ì—†ëŠ” ì„œë¹„ìŠ¤
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
  namespace: production
  annotations:
    backup.company.com/include: "true"
    backup.company.com/strategy: "stateless"
    backup.velero.io/backup-volumes-excludes: "tmp,cache"
spec:
  template:
    spec:
      containers:
      - name: web-app
        image: nginx:1.21
        volumeMounts:
        - name: web-content
          mountPath: /usr/share/nginx/html
        - name: tmp
          mountPath: /tmp
        - name: cache
          mountPath: /var/cache/nginx
      volumes:
      - name: web-content
        persistentVolumeClaim:
          claimName: web-content-pvc
      - name: tmp
        emptyDir: {}
      - name: cache
        emptyDir: {}
```

## ğŸ”„ ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… ìë™í™”

### MySQL/PostgreSQL ë°±ì—… ì‹œìŠ¤í…œ

```bash
#!/bin/bash
# database-backup-system.sh

# ì„¤ì •
DB_TYPE="mysql"  # mysql ë˜ëŠ” postgresql
NAMESPACE="production"
BACKUP_STORAGE_CLASS="backup-storage"
RETENTION_DAYS=30

# MySQL ë°±ì—… í•¨ìˆ˜
backup_mysql() {
    local db_pod=$1
    local backup_name="mysql-backup-$(date +%Y%m%d-%H%M%S)"
    
    echo "Creating MySQL backup: $backup_name"
    
    # ë°±ì—… Job ìƒì„±
    cat << EOF | kubectl apply -f -
apiVersion: batch/v1
kind: Job
metadata:
  name: $backup_name
  namespace: $NAMESPACE
spec:
  template:
    spec:
      containers:
      - name: mysql-backup
        image: mysql:8.0
        command: ["/bin/bash"]
        args:
        - -c
        - |
          # ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… ìƒì„±
          mysqldump --single-transaction --routines --triggers \
            -h \$MYSQL_HOST -u \$MYSQL_USER -p\$MYSQL_PASSWORD \
            --all-databases > /backup/mysql-dump-\$(date +%Y%m%d-%H%M%S).sql
          
          # ì••ì¶•
          gzip /backup/mysql-dump-*.sql
          
          echo "MySQL backup completed"
        env:
        - name: MYSQL_HOST
          value: "mysql-service"
        - name: MYSQL_USER
          value: "root"
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: password
        volumeMounts:
        - name: backup-volume
          mountPath: /backup
      volumes:
      - name: backup-volume
        persistentVolumeClaim:
          claimName: mysql-backup-pvc
      restartPolicy: OnFailure
  backoffLimit: 3

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-backup-pvc
  namespace: $NAMESPACE
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: $BACKUP_STORAGE_CLASS
  resources:
    requests:
      storage: 50Gi
EOF
}

# PostgreSQL ë°±ì—… í•¨ìˆ˜
backup_postgresql() {
    local db_pod=$1
    local backup_name="postgresql-backup-$(date +%Y%m%d-%H%M%S)"
    
    echo "Creating PostgreSQL backup: $backup_name"
    
    cat << EOF | kubectl apply -f -
apiVersion: batch/v1
kind: Job
metadata:
  name: $backup_name
  namespace: $NAMESPACE
spec:
  template:
    spec:
      containers:
      - name: postgresql-backup
        image: postgres:13
        command: ["/bin/bash"]
        args:
        - -c
        - |
          # ëª¨ë“  ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—…
          pg_dumpall -h \$POSTGRES_HOST -U \$POSTGRES_USER \
            > /backup/postgresql-dump-\$(date +%Y%m%d-%H%M%S).sql
          
          # ì••ì¶•
          gzip /backup/postgresql-dump-*.sql
          
          echo "PostgreSQL backup completed"
        env:
        - name: POSTGRES_HOST
          value: "postgresql-service"
        - name: POSTGRES_USER
          value: "postgres"
        - name: PGPASSWORD
          valueFrom:
            secretKeyRef:
              name: postgresql-secret
              key: password
        volumeMounts:
        - name: backup-volume
          mountPath: /backup
      volumes:
      - name: backup-volume
        persistentVolumeClaim:
          claimName: postgresql-backup-pvc
      restartPolicy: OnFailure
  backoffLimit: 3
EOF
}

# ë°±ì—… ì •ë¦¬ í•¨ìˆ˜
cleanup_old_backups() {
    echo "Cleaning up backups older than $RETENTION_DAYS days..."
    
    # ì˜¤ë˜ëœ ë°±ì—… Job ì‚­ì œ
    kubectl get jobs -n $NAMESPACE -o json | jq -r \
        ".items[] | select(.metadata.name | test(\"^(mysql|postgresql)-backup-\")) | select(.metadata.creationTimestamp | fromdateiso8601 < (now - ($RETENTION_DAYS * 86400))) | .metadata.name" | \
        xargs -r kubectl delete job -n $NAMESPACE
}

# ë©”ì¸ ì‹¤í–‰
case $DB_TYPE in
    mysql)
        backup_mysql "mysql-0"
        ;;
    postgresql)
        backup_postgresql "postgresql-0"
        ;;
    *)
        echo "Unsupported database type: $DB_TYPE"
        exit 1
        ;;
esac

cleanup_old_backups
```

### ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… CronJob

```yaml
# database-backup-cronjobs.yaml
---
# MySQL ìë™ ë°±ì—…
apiVersion: batch/v1
kind: CronJob
metadata:
  name: mysql-backup-cron
  namespace: production
spec:
  schedule: "0 2 * * *"  # ë§¤ì¼ ì˜¤ì „ 2ì‹œ
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: mysql-backup
            image: mysql:8.0
            command: ["/bin/bash"]
            args:
            - -c
            - |
              BACKUP_FILE="/backup/mysql-backup-$(date +%Y%m%d-%H%M%S).sql"
              
              echo "Starting MySQL backup: $BACKUP_FILE"
              
              # ë°±ì—… ì‹¤í–‰
              mysqldump --single-transaction --routines --triggers \
                -h $MYSQL_HOST -u $MYSQL_USER -p$MYSQL_PASSWORD \
                --all-databases > "$BACKUP_FILE"
              
              if [ $? -eq 0 ]; then
                # ì••ì¶•
                gzip "$BACKUP_FILE"
                echo "MySQL backup completed successfully: ${BACKUP_FILE}.gz"
                
                # ë°±ì—… íŒŒì¼ í¬ê¸° í™•ì¸
                ls -lh "${BACKUP_FILE}.gz"
                
                # ì˜¤ë˜ëœ ë°±ì—… ì •ë¦¬ (30ì¼ ì´ìƒ)
                find /backup -name "mysql-backup-*.sql.gz" -mtime +30 -delete
                echo "Old backup cleanup completed"
              else
                echo "MySQL backup failed"
                exit 1
              fi
            env:
            - name: MYSQL_HOST
              value: "mysql-service"
            - name: MYSQL_USER
              value: "backup"
            - name: MYSQL_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-backup-secret
                  key: password
            volumeMounts:
            - name: backup-volume
              mountPath: /backup
            resources:
              requests:
                cpu: 100m
                memory: 256Mi
              limits:
                cpu: 500m
                memory: 1Gi
          volumes:
          - name: backup-volume
            persistentVolumeClaim:
              claimName: mysql-backup-pvc
          restartPolicy: OnFailure

---
# PostgreSQL ìë™ ë°±ì—…
apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgresql-backup-cron
  namespace: production
spec:
  schedule: "30 2 * * *"  # ë§¤ì¼ ì˜¤ì „ 2ì‹œ 30ë¶„
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: postgresql-backup
            image: postgres:13
            command: ["/bin/bash"]
            args:
            - -c
            - |
              BACKUP_FILE="/backup/postgresql-backup-$(date +%Y%m%d-%H%M%S).sql"
              
              echo "Starting PostgreSQL backup: $BACKUP_FILE"
              
              # ì „ì²´ í´ëŸ¬ìŠ¤í„° ë°±ì—…
              pg_dumpall -h $POSTGRES_HOST -U $POSTGRES_USER > "$BACKUP_FILE"
              
              if [ $? -eq 0 ]; then
                # ì••ì¶•
                gzip "$BACKUP_FILE"
                echo "PostgreSQL backup completed: ${BACKUP_FILE}.gz"
                
                # ë°±ì—… ê²€ì¦
                zcat "${BACKUP_FILE}.gz" | head -10
                
                # ì˜¤ë˜ëœ ë°±ì—… ì •ë¦¬
                find /backup -name "postgresql-backup-*.sql.gz" -mtime +30 -delete
              else
                echo "PostgreSQL backup failed"
                exit 1
              fi
            env:
            - name: POSTGRES_HOST
              value: "postgresql-service"
            - name: POSTGRES_USER
              value: "postgres"
            - name: PGPASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgresql-secret
                  key: password
            volumeMounts:
            - name: backup-volume
              mountPath: /backup
          volumes:
          - name: backup-volume
            persistentVolumeClaim:
              claimName: postgresql-backup-pvc
          restartPolicy: OnFailure
```

## âš¡ ì¬í•´ ë³µêµ¬ ì ˆì°¨

### ì „ì²´ í´ëŸ¬ìŠ¤í„° ë³µì›

```bash
#!/bin/bash
# cluster-disaster-recovery.sh

BACKUP_DATE=${1:-$(date +%Y%m%d)}
ETCD_BACKUP_DIR="/var/backups/etcd"
VELERO_BACKUP_NAME=""

echo "=== Kubernetes Cluster Disaster Recovery ==="
echo "Backup date: $BACKUP_DATE"

# 1. etcd ë³µì›
restore_etcd() {
    echo "Step 1: Restoring etcd..."
    
    local etcd_backup=$(find "$ETCD_BACKUP_DIR" -name "*${BACKUP_DATE}*.db.gz" | head -1)
    
    if [ -z "$etcd_backup" ]; then
        echo "ERROR: No etcd backup found for date $BACKUP_DATE"
        exit 1
    fi
    
    echo "Using etcd backup: $etcd_backup"
    
    # ëª¨ë“  ë§ˆìŠ¤í„° ë…¸ë“œì—ì„œ etcd ì¤‘ì§€
    for master in $(kubectl get nodes -l node-role.kubernetes.io/control-plane -o name | cut -d/ -f2); do
        echo "Stopping etcd on $master"
        ssh "$master" "systemctl stop kubelet"
        ssh "$master" "systemctl stop etcd" 2>/dev/null || true
    done
    
    # ê¸°ì¡´ etcd ë°ì´í„° ë°±ì—…
    ssh "$MASTER_NODE" "mv /var/lib/etcd /var/lib/etcd-backup-$(date +%s)" 2>/dev/null || true
    
    # etcd ë³µì› ì‹¤í–‰
    local temp_file="/tmp/etcd-restore.db"
    gunzip -c "$etcd_backup" > "$temp_file"
    
    ETCDCTL_API=3 etcdctl snapshot restore "$temp_file" \
        --data-dir="/var/lib/etcd" \
        --name="default" \
        --initial-cluster="default=https://127.0.0.1:2380" \
        --initial-advertise-peer-urls="https://127.0.0.1:2380"
    
    # ê¶Œí•œ ì„¤ì •
    chown -R etcd:etcd /var/lib/etcd
    
    # kubelet ì‹œì‘
    systemctl start kubelet
    
    echo "etcd restoration completed"
}

# 2. í´ëŸ¬ìŠ¤í„° ìƒíƒœ í™•ì¸
verify_cluster_health() {
    echo "Step 2: Verifying cluster health..."
    
    # API ì„œë²„ ì‘ë‹µ ëŒ€ê¸°
    local timeout=300
    while [ $timeout -gt 0 ]; do
        if kubectl cluster-info >/dev/null 2>&1; then
            echo "âœ… API server is responding"
            break
        fi
        echo "Waiting for API server... ($timeout seconds remaining)"
        sleep 10
        timeout=$((timeout - 10))
    done
    
    if [ $timeout -le 0 ]; then
        echo "âŒ API server is not responding after 5 minutes"
        exit 1
    fi
    
    # ë…¸ë“œ ìƒíƒœ í™•ì¸
    echo "Node status:"
    kubectl get nodes
    
    # ì‹œìŠ¤í…œ Pod ìƒíƒœ í™•ì¸
    echo "System pods status:"
    kubectl get pods -n kube-system
}

# 3. ì• í”Œë¦¬ì¼€ì´ì…˜ ë°ì´í„° ë³µì› (Velero)
restore_applications() {
    echo "Step 3: Restoring applications with Velero..."
    
    # ì‚¬ìš© ê°€ëŠ¥í•œ ë°±ì—… í™•ì¸
    velero backup get | grep "$BACKUP_DATE"
    
    if [ $? -ne 0 ]; then
        echo "WARNING: No Velero backup found for $BACKUP_DATE"
        echo "Available backups:"
        velero backup get
        return 1
    fi
    
    # ìš´ì˜ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë³µì›
    VELERO_BACKUP_NAME=$(velero backup get | grep "$BACKUP_DATE" | grep "production" | head -1 | awk '{print $1}')
    
    if [ -n "$VELERO_BACKUP_NAME" ]; then
        echo "Restoring from Velero backup: $VELERO_BACKUP_NAME"
        
        velero restore create \
            --from-backup "$VELERO_BACKUP_NAME" \
            --restore-volumes=true \
            --wait
        
        echo "Velero restoration completed"
    fi
}

# 4. ë°ì´í„°ë² ì´ìŠ¤ ë³µì›
restore_databases() {
    echo "Step 4: Restoring databases..."
    
    # MySQL ë³µì›
    if kubectl get deployment mysql -n production >/dev/null 2>&1; then
        echo "Restoring MySQL database..."
        
        local mysql_backup="/backup/mysql-backup-${BACKUP_DATE}*.sql.gz"
        local backup_file=$(ls $mysql_backup 2>/dev/null | head -1)
        
        if [ -f "$backup_file" ]; then
            # MySQL Podì—ì„œ ë³µì› ì‹¤í–‰
            kubectl exec -n production deployment/mysql -- bash -c "
                gunzip -c /backup/$(basename $backup_file) | mysql -u root -p\$MYSQL_ROOT_PASSWORD
            "
            echo "MySQL restoration completed"
        else
            echo "WARNING: MySQL backup not found for $BACKUP_DATE"
        fi
    fi
    
    # PostgreSQL ë³µì›
    if kubectl get deployment postgresql -n production >/dev/null 2>&1; then
        echo "Restoring PostgreSQL database..."
        
        local pg_backup="/backup/postgresql-backup-${BACKUP_DATE}*.sql.gz"
        local backup_file=$(ls $pg_backup 2>/dev/null | head -1)
        
        if [ -f "$backup_file" ]; then
            kubectl exec -n production deployment/postgresql -- bash -c "
                gunzip -c /backup/$(basename $backup_file) | psql -U postgres
            "
            echo "PostgreSQL restoration completed"
        else
            echo "WARNING: PostgreSQL backup not found for $BACKUP_DATE"
        fi
    fi
}

# 5. ì„œë¹„ìŠ¤ ê²€ì¦
verify_services() {
    echo "Step 5: Verifying services..."
    
    # ëª¨ë“  Podê°€ Running ìƒíƒœê°€ ë  ë•Œê¹Œì§€ ëŒ€ê¸°
    echo "Waiting for all pods to be ready..."
    kubectl wait --for=condition=Ready pods --all --all-namespaces --timeout=600s
    
    # ì„œë¹„ìŠ¤ ì—”ë“œí¬ì¸íŠ¸ í™•ì¸
    echo "Service endpoints:"
    kubectl get endpoints --all-namespaces | grep -v "none"
    
    # Ingress ìƒíƒœ í™•ì¸
    echo "Ingress status:"
    kubectl get ingress --all-namespaces
    
    # ê¸°ë³¸ ì—°ê²°ì„± í…ŒìŠ¤íŠ¸
    echo "Testing basic connectivity..."
    kubectl run connectivity-test --image=busybox --rm -it --restart=Never -- \
        nslookup kubernetes.default.svc.cluster.local
}

# 6. ë³µì› í›„ ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸
post_recovery_checklist() {
    echo "Step 6: Post-recovery checklist..."
    
    cat << EOF
=== Post-Recovery Checklist ===

â–¡ Cluster Status
  - API server responding: $(kubectl cluster-info >/dev/null 2>&1 && echo "âœ…" || echo "âŒ")
  - All nodes ready: $(kubectl get nodes | grep -c "Ready")
  - System pods running: $(kubectl get pods -n kube-system | grep -c "Running")

â–¡ Application Status
  - Production pods: $(kubectl get pods -n production | grep -c "Running")
  - Database connections: [Manual verification needed]
  - External services: [Manual verification needed]

â–¡ Data Integrity
  - Database consistency: [Manual verification needed]
  - File system integrity: [Manual verification needed]
  - Backup verification: [Manual verification needed]

â–¡ Security
  - Certificate validity: $(kubeadm certs check-expiration | grep -c "CERTIFICATE")
  - RBAC policies: [Manual verification needed]
  - Network policies: [Manual verification needed]

â–¡ Monitoring
  - Prometheus targets: [Manual verification needed]
  - Grafana dashboards: [Manual verification needed]
  - Alerting rules: [Manual verification needed]

Next steps:
1. Verify application functionality
2. Check data consistency
3. Monitor system performance
4. Update backup schedules if needed
5. Document lessons learned
EOF
}

# ë©”ì¸ ì‹¤í–‰
main() {
    echo "Starting disaster recovery process..."
    read -p "This will restore the cluster from backups. Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Recovery aborted"
        exit 0
    fi
    
    restore_etcd
    verify_cluster_health
    restore_applications
    restore_databases
    verify_services
    post_recovery_checklist
    
    echo ""
    echo "=== Disaster Recovery Completed ==="
    echo "Please review the checklist above and perform manual verifications."
}

# ì‹¤í–‰
if [ "$1" = "--dry-run" ]; then
    echo "DRY RUN MODE - No actual changes will be made"
    echo "Would restore from backups dated: $BACKUP_DATE"
    exit 0
else
    main "$@"
fi
```

## ğŸ“‹ ë°±ì—… ê²€ì¦ ë° ëª¨ë‹ˆí„°ë§

### ë°±ì—… ìƒíƒœ ëª¨ë‹ˆí„°ë§

```bash
#!/bin/bash
# backup-monitoring.sh

echo "=== Backup Status Monitoring ==="

# etcd ë°±ì—… ìƒíƒœ í™•ì¸
check_etcd_backups() {
    echo "1. etcd Backup Status:"
    
    local backup_dir="/var/backups/etcd"
    local latest_backup=$(ls -t "$backup_dir"/etcd-snapshot-*.db.gz 2>/dev/null | head -1)
    
    if [ -n "$latest_backup" ]; then
        local backup_age=$(find "$latest_backup" -mtime +1 2>/dev/null)
        if [ -z "$backup_age" ]; then
            echo "  âœ… Latest etcd backup: $(basename $latest_backup)"
            echo "     Age: $(stat -c %y "$latest_backup")"
            echo "     Size: $(du -h "$latest_backup" | awk '{print $1}')"
        else
            echo "  âš ï¸ etcd backup is older than 24 hours"
            echo "     Latest backup: $(basename $latest_backup)"
        fi
    else
        echo "  âŒ No etcd backups found"
    fi
    echo
}

# Velero ë°±ì—… ìƒíƒœ í™•ì¸
check_velero_backups() {
    echo "2. Velero Backup Status:"
    
    if command -v velero >/dev/null 2>&1; then
        echo "Recent Velero backups:"
        velero backup get | head -10
        
        # ì‹¤íŒ¨í•œ ë°±ì—… í™•ì¸
        local failed_backups=$(velero backup get | grep -c "Failed\|PartiallyFailed")
        if [ "$failed_backups" -gt 0 ]; then
            echo "  âš ï¸ $failed_backups failed backup(s) found"
            velero backup get | grep -E "Failed|PartiallyFailed"
        else
            echo "  âœ… No failed backups"
        fi
    else
        echo "  âš ï¸ Velero CLI not available"
    fi
    echo
}

# ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… ìƒíƒœ í™•ì¸
check_database_backups() {
    echo "3. Database Backup Status:"
    
    # MySQL ë°±ì—… í™•ì¸
    if kubectl get pvc mysql-backup-pvc -n production >/dev/null 2>&1; then
        local mysql_pod=$(kubectl get pods -n production -l app=mysql-backup -o name | head -1)
        if [ -n "$mysql_pod" ]; then
            local latest_mysql=$(kubectl exec -n production "$mysql_pod" -- ls -t /backup/mysql-backup-*.sql.gz 2>/dev/null | head -1)
            if [ -n "$latest_mysql" ]; then
                echo "  âœ… Latest MySQL backup: $latest_mysql"
            else
                echo "  âŒ No MySQL backups found"
            fi
        fi
    fi
    
    # PostgreSQL ë°±ì—… í™•ì¸
    if kubectl get pvc postgresql-backup-pvc -n production >/dev/null 2>&1; then
        local pg_pod=$(kubectl get pods -n production -l app=postgresql-backup -o name | head -1)
        if [ -n "$pg_pod" ]; then
            local latest_pg=$(kubectl exec -n production "$pg_pod" -- ls -t /backup/postgresql-backup-*.sql.gz 2>/dev/null | head -1)
            if [ -n "$latest_pg" ]; then
                echo "  âœ… Latest PostgreSQL backup: $latest_pg"
            else
                echo "  âŒ No PostgreSQL backups found"
            fi
        fi
    fi
    echo
}

# ë°±ì—… ì¼ì • í™•ì¸
check_backup_schedules() {
    echo "4. Backup Schedule Status:"
    
    # CronJob ìƒíƒœ í™•ì¸
    echo "Active backup CronJobs:"
    kubectl get cronjobs --all-namespaces | grep -E "(backup|etcd)" | while read ns name schedule suspend active last; do
        if [ "$suspend" = "False" ]; then
            echo "  âœ… $ns/$name - Next: $schedule"
        else
            echo "  âš ï¸ $ns/$name - SUSPENDED"
        fi
    done
    
    # Velero ìŠ¤ì¼€ì¤„ í™•ì¸
    if command -v velero >/dev/null 2>&1; then
        echo
        echo "Velero backup schedules:"
        velero schedule get
    fi
    echo
}

# ìŠ¤í† ë¦¬ì§€ ìš©ëŸ‰ í™•ì¸
check_backup_storage() {
    echo "5. Backup Storage Usage:"
    
    # ë°±ì—… PVC ìš©ëŸ‰ í™•ì¸
    kubectl get pvc --all-namespaces | grep backup | while read ns name status volume capacity access storage class age; do
        echo "  $ns/$name: $capacity ($status)"
    done
    echo
}

# ì‹¤í–‰
check_etcd_backups
check_velero_backups
check_database_backups
check_backup_schedules
check_backup_storage

echo "=== Backup Monitoring Completed ==="
```

## ğŸ“ ë°±ì—… ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

### 1. ë°±ì—… ì „ëµ ìˆ˜ë¦½

- **3-2-1 ê·œì¹™**: 3ê°œ ë³µì‚¬ë³¸, 2ê°œ ë‹¤ë¥¸ ë¯¸ë””ì–´, 1ê°œ ì˜¤í”„ì‚¬ì´íŠ¸
- **RTO/RPO ì •ì˜**: ë¹„ì¦ˆë‹ˆìŠ¤ ìš”êµ¬ì‚¬í•­ì— ë”°ë¥¸ ëª©í‘œ ì„¤ì •
- **ì •ê¸° í…ŒìŠ¤íŠ¸**: ë°±ì—… ë³µì› ì ˆì°¨ì˜ ì •ê¸°ì  í…ŒìŠ¤íŠ¸
- **ë¬¸ì„œí™”**: ëª¨ë“  ë°±ì—… ë° ë³µì› ì ˆì°¨ ë¬¸ì„œí™”

### 2. ìë™í™” ë° ëª¨ë‹ˆí„°ë§

- **ìë™í™”ëœ ë°±ì—…**: CronJobì„ í†µí•œ ì •ê¸° ë°±ì—…
- **ë°±ì—… ê²€ì¦**: ë°±ì—… íŒŒì¼ì˜ ë¬´ê²°ì„± ì •ê¸° ê²€ì¦
- **ì•Œë¦¼ ì„¤ì •**: ë°±ì—… ì‹¤íŒ¨ ì‹œ ì¦‰ì‹œ ì•Œë¦¼
- **ìš©ëŸ‰ ê´€ë¦¬**: ë°±ì—… ìŠ¤í† ë¦¬ì§€ ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§

### 3. ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

- **ì•”í˜¸í™”**: ì „ì†¡ ì¤‘ ë° ì €ì¥ ì‹œ ì•”í˜¸í™”
- **ì ‘ê·¼ ì œì–´**: ë°±ì—… ë°ì´í„°ì— ëŒ€í•œ ì—„ê²©í•œ ì ‘ê·¼ ì œì–´
- **ê°ì‚¬ ë¡œê·¸**: ë°±ì—… ê´€ë ¨ ëª¨ë“  í™œë™ ë¡œê¹…
- **ì˜¤í”„ì‚¬ì´íŠ¸ ì €ì¥**: ì¬í•´ ëŒ€ë¹„ ì˜¤í”„ì‚¬ì´íŠ¸ ë°±ì—…

---

> ğŸ’¡ **ì‹¤ì „ ê²½í—˜**: ë°±ì—…ì˜ í•µì‹¬ì€ ë³µì› í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤. ì •ê¸°ì ìœ¼ë¡œ ë°±ì—…ì—ì„œ ë³µì› í…ŒìŠ¤íŠ¸ë¥¼ ìˆ˜í–‰í•˜ì—¬ ì‹¤ì œ ì¬í•´ ìƒí™©ì—ì„œ ì‹ ì†í•˜ê²Œ ëŒ€ì‘í•  ìˆ˜ ìˆë„ë¡ ì¤€ë¹„í•˜ì„¸ìš”. íŠ¹íˆ etcd ë°±ì—…ì€ í´ëŸ¬ìŠ¤í„°ì˜ ìƒëª…ì„ ì´ë¯€ë¡œ ë§¤ì¼ ë°±ì—…í•˜ê³  ì£¼ê¸°ì ìœ¼ë¡œ ë³µì› í…ŒìŠ¤íŠ¸ë¥¼ ìˆ˜í–‰í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

íƒœê·¸: #backup #disaster-recovery #etcd #velero #database #restoration #onprem
