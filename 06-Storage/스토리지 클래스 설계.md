# ìŠ¤í† ë¦¬ì§€ í´ë˜ìŠ¤ ì„¤ê³„

## ğŸ¯ ê°œìš”

ì¿ ë²„ë„¤í‹°ìŠ¤ í™˜ê²½ì—ì„œ ë‹¤ì–‘í•œ ì›Œí¬ë¡œë“œ ìš”êµ¬ì‚¬í•­ì— ë§ëŠ” StorageClass ì„¤ê³„ ì „ëµê³¼ ì˜¨í”„ë ˜ í™˜ê²½ì—ì„œì˜ ìŠ¤í† ë¦¬ì§€ ê³„ì¸µí™”, ì„±ëŠ¥ ìµœì í™” ë°©ë²•ì„ ë‹¤ë£¹ë‹ˆë‹¤.

## ğŸ“Š ìŠ¤í† ë¦¬ì§€ í´ë˜ìŠ¤ ë¶„ë¥˜ ì²´ê³„

### ì„±ëŠ¥ ê¸°ë°˜ ë¶„ë¥˜

```yaml
# storage-classes-performance.yaml
---
# ê³ ì„±ëŠ¥ SSD ìŠ¤í† ë¦¬ì§€ (ë°ì´í„°ë² ì´ìŠ¤ìš©)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: ssd-high-performance
  annotations:
    storageclass.kubernetes.io/is-default-class: "false"
    description: "High-performance SSD storage for databases"
spec:
  provisioner: kubernetes.io/no-provisioner  # Local storage
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Retain
  allowVolumeExpansion: false
  parameters:
    type: "ssd"
    performance-tier: "high"
    encryption: "true"

---
# ì¤‘ê°„ ì„±ëŠ¥ SSD ìŠ¤í† ë¦¬ì§€ (ì¼ë°˜ ì• í”Œë¦¬ì¼€ì´ì…˜ìš©)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: ssd-standard
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
    description: "Standard SSD storage for general applications"
spec:
  provisioner: driver.longhorn.io
  volumeBindingMode: Immediate
  reclaimPolicy: Delete
  allowVolumeExpansion: true
  parameters:
    numberOfReplicas: "3"
    staleReplicaTimeout: "2880"
    fromBackup: ""
    fsType: "ext4"
    diskSelector: "ssd"

---
# ëŒ€ìš©ëŸ‰ HDD ìŠ¤í† ë¦¬ì§€ (ë¡œê·¸, ë°±ì—…ìš©)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: hdd-bulk-storage
  annotations:
    description: "Large capacity HDD storage for logs and backups"
spec:
  provisioner: k8s-sigs.io/nfs-subdir-external-provisioner
  volumeBindingMode: Immediate
  reclaimPolicy: Retain
  allowVolumeExpansion: true
  parameters:
    archiveOnDelete: "true"
    pathPattern: "bulk-storage/${.PVC.namespace}/${.PVC.name}"
    server: "192.168.1.100"
    path: "/export/bulk-storage"

---
# ë©”ëª¨ë¦¬ ê¸°ë°˜ ìŠ¤í† ë¦¬ì§€ (ìºì‹œìš©)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: memory-storage
  annotations:
    description: "Memory-based storage for caching"
spec:
  provisioner: kubernetes.io/no-provisioner
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Delete
  allowVolumeExpansion: false
  parameters:
    type: "memory"
    mount-options: "size=1G,noatime"
```

### ìš©ë„ë³„ ë¶„ë¥˜

```yaml
# storage-classes-workload.yaml
---
# ë°ì´í„°ë² ì´ìŠ¤ ì „ìš© ìŠ¤í† ë¦¬ì§€
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: database-storage
  annotations:
    description: "Optimized storage for database workloads"
spec:
  provisioner: driver.longhorn.io
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Retain
  allowVolumeExpansion: true
  parameters:
    numberOfReplicas: "3"
    staleReplicaTimeout: "2880"
    dataLocality: "strict-local"  # ë¡œì»¬ ë°ì´í„° ìš°ì„ 
    fsType: "ext4"
    mkfsParams: "-F -E lazy_itable_init=0,lazy_journal_init=0"  # ë¹ ë¥¸ í¬ë§·
    recurringJobSelector: '[{"name":"backup-db", "isGroup":false}]'

---
# ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ìš© ê³µìœ  ìŠ¤í† ë¦¬ì§€
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: webapp-shared-storage
  annotations:
    description: "Shared storage for web applications"
spec:
  provisioner: k8s-sigs.io/nfs-subdir-external-provisioner
  volumeBindingMode: Immediate
  reclaimPolicy: Delete
  allowVolumeExpansion: true
  parameters:
    server: "192.168.1.100"
    path: "/export/webapp-shared"
    archiveOnDelete: "false"
    mountOptions: "nfsvers=4.1,hard,rsize=1048576,wsize=1048576"

---
# ë¡œê¹… ì‹œìŠ¤í…œìš© ìŠ¤í† ë¦¬ì§€
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: logging-storage
  annotations:
    description: "High-throughput storage for logging systems"
spec:
  provisioner: driver.longhorn.io
  volumeBindingMode: Immediate
  reclaimPolicy: Delete
  allowVolumeExpansion: true
  parameters:
    numberOfReplicas: "2"  # ë¡œê·¸ëŠ” ë³µì œë³¸ ìˆ˜ ì¤„ì„
    staleReplicaTimeout: "1440"  # ë” ë¹ ë¥¸ ë³µêµ¬
    fsType: "xfs"  # ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ì— ìµœì í™”
    dataLocality: "best-effort"

---
# CI/CD íŒŒì´í”„ë¼ì¸ìš© ì„ì‹œ ìŠ¤í† ë¦¬ì§€
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: cicd-temp-storage
  annotations:
    description: "Temporary high-speed storage for CI/CD pipelines"
spec:
  provisioner: kubernetes.io/no-provisioner
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Delete
  allowVolumeExpansion: false
  parameters:
    type: "local-ssd"
    mount-options: "noatime,nodiratime"

---
# ë°±ì—… ì „ìš© ìŠ¤í† ë¦¬ì§€
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: backup-storage
  annotations:
    description: "Cost-effective storage for backups"
spec:
  provisioner: k8s-sigs.io/nfs-subdir-external-provisioner
  volumeBindingMode: Immediate
  reclaimPolicy: Retain
  allowVolumeExpansion: true
  parameters:
    server: "192.168.1.200"  # ë°±ì—… ì „ìš© NFS ì„œë²„
    path: "/export/backups"
    archiveOnDelete: "true"
    pathPattern: "backups/${.PVC.namespace}/${.PVC.name}/${.PVC.annotations.backup-date}"
```

### í™˜ê²½ë³„ ë¶„ë¥˜

```yaml
# storage-classes-environment.yaml
---
# ìš´ì˜í™˜ê²½ ê³ ê°€ìš©ì„± ìŠ¤í† ë¦¬ì§€
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: production-ha-storage
  annotations:
    description: "High-availability storage for production"
spec:
  provisioner: rbd.csi.ceph.com
  volumeBindingMode: Immediate
  reclaimPolicy: Retain
  allowVolumeExpansion: true
  parameters:
    clusterID: "production-ceph-cluster"
    pool: "production-rbd"
    imageFormat: "2"
    imageFeatures: "layering,deep-flatten,exclusive-lock,object-map,fast-diff"
    
    # CSI ì‹œí¬ë¦¿ ì°¸ì¡°
    csi.storage.k8s.io/provisioner-secret-name: "ceph-csi-rbd-provisioner"
    csi.storage.k8s.io/provisioner-secret-namespace: "ceph-csi-rbd"
    csi.storage.k8s.io/controller-expand-secret-name: "ceph-csi-rbd-provisioner"
    csi.storage.k8s.io/controller-expand-secret-namespace: "ceph-csi-rbd"
    csi.storage.k8s.io/node-stage-secret-name: "ceph-csi-rbd-node"
    csi.storage.k8s.io/node-stage-secret-namespace: "ceph-csi-rbd"
    
    # ì•”í˜¸í™” í™œì„±í™”
    encrypted: "true"

---
# ìŠ¤í…Œì´ì§• í™˜ê²½ ìŠ¤í† ë¦¬ì§€
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: staging-storage
  annotations:
    description: "Standard storage for staging environment"
spec:
  provisioner: driver.longhorn.io
  volumeBindingMode: Immediate
  reclaimPolicy: Delete
  allowVolumeExpansion: true
  parameters:
    numberOfReplicas: "2"  # ìš´ì˜ë³´ë‹¤ ë‚®ì€ ë³µì œ ìˆ˜ì¤€
    staleReplicaTimeout: "2880"
    fsType: "ext4"
    
---
# ê°œë°œí™˜ê²½ ìŠ¤í† ë¦¬ì§€
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: development-storage
  annotations:
    description: "Fast, temporary storage for development"
spec:
  provisioner: kubernetes.io/no-provisioner
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Delete
  allowVolumeExpansion: false
  parameters:
    type: "local"
    performance: "standard"

---
# í…ŒìŠ¤íŠ¸í™˜ê²½ ìŠ¤í† ë¦¬ì§€
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: testing-storage
  annotations:
    description: "Ephemeral storage for testing"
spec:
  provisioner: k8s-sigs.io/nfs-subdir-external-provisioner
  volumeBindingMode: Immediate
  reclaimPolicy: Delete
  allowVolumeExpansion: true
  parameters:
    server: "192.168.1.150"
    path: "/export/testing"
    archiveOnDelete: "false"
```

## ğŸ—ï¸ ìŠ¤í† ë¦¬ì§€ í´ë˜ìŠ¤ ì„¤ê³„ íŒ¨í„´

### ê³„ì¸µí™”ëœ ìŠ¤í† ë¦¬ì§€ ì „ëµ

```yaml
# tiered-storage-strategy.yaml
---
# Tier 1: ì´ˆê³ ì„±ëŠ¥ (NVMe SSD)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: tier1-nvme-ssd
  annotations:
    storage.company.com/tier: "1"
    storage.company.com/performance: "ultra"
    storage.company.com/cost: "high"
spec:
  provisioner: kubernetes.io/no-provisioner
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Retain
  allowVolumeExpansion: false
  parameters:
    type: "nvme-ssd"
    mount-options: "noatime,nodiratime,nobarrier"

---
# Tier 2: ê³ ì„±ëŠ¥ (SATA SSD)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: tier2-sata-ssd
  annotations:
    storage.company.com/tier: "2"
    storage.company.com/performance: "high"
    storage.company.com/cost: "medium"
spec:
  provisioner: driver.longhorn.io
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Delete
  allowVolumeExpansion: true
  parameters:
    numberOfReplicas: "3"
    diskSelector: "ssd"
    nodeSelector: "storage-tier=high"

---
# Tier 3: í‘œì¤€ ì„±ëŠ¥ (HDD RAID)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: tier3-hdd-raid
  annotations:
    storage.company.com/tier: "3"
    storage.company.com/performance: "standard"
    storage.company.com/cost: "low"
spec:
  provisioner: k8s-sigs.io/nfs-subdir-external-provisioner
  volumeBindingMode: Immediate
  reclaimPolicy: Delete
  allowVolumeExpansion: true
  parameters:
    server: "storage-tier3.company.local"
    path: "/export/standard"

---
# Tier 4: ì•„ì¹´ì´ë¸Œ (ì €ì† ëŒ€ìš©ëŸ‰)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: tier4-archive
  annotations:
    storage.company.com/tier: "4"
    storage.company.com/performance: "low"
    storage.company.com/cost: "very-low"
spec:
  provisioner: k8s-sigs.io/nfs-subdir-external-provisioner
  volumeBindingMode: Immediate
  reclaimPolicy: Retain
  allowVolumeExpansion: true
  parameters:
    server: "archive-storage.company.local"
    path: "/export/archive"
    archiveOnDelete: "true"
```

### ë³µì œ ìˆ˜ì¤€ë³„ ë¶„ë¥˜

```yaml
# replication-levels.yaml
---
# ë‹¨ì¼ ë³µì œë³¸ (ê°œë°œ/í…ŒìŠ¤íŠ¸ìš©)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: single-replica
  annotations:
    description: "Single replica for non-critical workloads"
spec:
  provisioner: driver.longhorn.io
  volumeBindingMode: Immediate
  reclaimPolicy: Delete
  allowVolumeExpansion: true
  parameters:
    numberOfReplicas: "1"
    staleReplicaTimeout: "2880"

---
# ì´ì¤‘ ë³µì œë³¸ (ì¼ë°˜ ìš´ì˜ìš©)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: dual-replica
  annotations:
    description: "Dual replica for standard production workloads"
spec:
  provisioner: driver.longhorn.io
  volumeBindingMode: Immediate
  reclaimPolicy: Delete
  allowVolumeExpansion: true
  parameters:
    numberOfReplicas: "2"
    staleReplicaTimeout: "2880"
    dataLocality: "best-effort"

---
# ì‚¼ì¤‘ ë³µì œë³¸ (ì¤‘ìš” ë°ì´í„°ìš©)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: triple-replica
  annotations:
    description: "Triple replica for critical data"
spec:
  provisioner: driver.longhorn.io
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Retain
  allowVolumeExpansion: true
  parameters:
    numberOfReplicas: "3"
    staleReplicaTimeout: "2880"
    dataLocality: "strict-local"

---
# êµì°¨ ë°ì´í„°ì„¼í„° ë³µì œ
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: cross-datacenter-replica
  annotations:
    description: "Cross-datacenter replication for disaster recovery"
spec:
  provisioner: rbd.csi.ceph.com
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Retain
  allowVolumeExpansion: true
  parameters:
    clusterID: "multi-site-ceph"
    pool: "cross-dc-pool"
    imageFormat: "2"
    imageFeatures: "layering,deep-flatten"
    # êµì°¨ ì‚¬ì´íŠ¸ ë³µì œ ì„¤ì •
    mirroringMode: "snapshot"
```

## ğŸ”§ ê³ ê¸‰ StorageClass ê¸°ëŠ¥

### ìë™ ë°±ì—… í†µí•©

```yaml
# backup-integrated-storage.yaml
---
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: auto-backup-storage
  annotations:
    description: "Storage with automated backup"
spec:
  provisioner: driver.longhorn.io
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Retain
  allowVolumeExpansion: true
  parameters:
    numberOfReplicas: "3"
    staleReplicaTimeout: "2880"
    
    # ìë™ ë°±ì—… ì„¤ì •
    recurringJobSelector: |
      [
        {"name":"backup-daily", "isGroup":false},
        {"name":"snapshot-hourly", "isGroup":false}
      ]

---
# Longhorn RecurringJob for backups
apiVersion: longhorn.io/v1beta1
kind: RecurringJob
metadata:
  name: backup-daily
  namespace: longhorn-system
spec:
  cron: "0 2 * * *"  # ë§¤ì¼ ì˜¤ì „ 2ì‹œ
  task: "backup"
  groups: []
  retain: 7  # 7ì¼ê°„ ë³´ê´€
  concurrency: 2

---
apiVersion: longhorn.io/v1beta1
kind: RecurringJob
metadata:
  name: snapshot-hourly
  namespace: longhorn-system
spec:
  cron: "0 * * * *"  # ë§¤ì‹œê°„
  task: "snapshot"
  groups: []
  retain: 24  # 24ì‹œê°„ ë³´ê´€
  concurrency: 5
```

### ì•”í˜¸í™” ìŠ¤í† ë¦¬ì§€

```yaml
# encrypted-storage-classes.yaml
---
# LUKS ì•”í˜¸í™” ìŠ¤í† ë¦¬ì§€
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: encrypted-storage
  annotations:
    description: "LUKS encrypted storage for sensitive data"
spec:
  provisioner: rbd.csi.ceph.com
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Retain
  allowVolumeExpansion: true
  parameters:
    clusterID: "ceph-cluster"
    pool: "encrypted-pool"
    imageFormat: "2"
    imageFeatures: "layering"
    
    # LUKS ì•”í˜¸í™” í™œì„±í™”
    encrypted: "true"
    encryptionKMSID: "vault-kms"
    
    # CSI ì•”í˜¸í™” í‚¤ ê´€ë¦¬
    csi.storage.k8s.io/provisioner-secret-name: "ceph-csi-rbd-provisioner"
    csi.storage.k8s.io/provisioner-secret-namespace: "ceph-csi-rbd"

---
# ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ ì•”í˜¸í™” ìŠ¤í† ë¦¬ì§€
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: app-level-encrypted
  annotations:
    description: "Storage for application-level encryption"
    encryption.company.com/type: "application"
    encryption.company.com/algorithm: "AES-256-GCM"
spec:
  provisioner: driver.longhorn.io
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Retain
  allowVolumeExpansion: true
  parameters:
    numberOfReplicas: "3"
    staleReplicaTimeout: "2880"
    dataLocality: "strict-local"
```

### ì„±ëŠ¥ ìµœì í™” ìŠ¤í† ë¦¬ì§€

```yaml
# performance-optimized-storage.yaml
---
# ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™” ìŠ¤í† ë¦¬ì§€
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: database-optimized
  annotations:
    description: "Optimized for database workloads"
spec:
  provisioner: kubernetes.io/no-provisioner
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Retain
  allowVolumeExpansion: false
  parameters:
    type: "local-nvme"
    fsType: "ext4"
    mkfsParams: "-F -E lazy_itable_init=0,lazy_journal_init=0,stride=16,stripe_width=64"
    mountOptions: "noatime,nodiratime,nobarrier,data=writeback"

---
# ê³ ì²˜ë¦¬ëŸ‰ ë¡œê¹… ìŠ¤í† ë¦¬ì§€
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: high-throughput-logging
  annotations:
    description: "High throughput storage for logging"
spec:
  provisioner: driver.longhorn.io
  volumeBindingMode: Immediate
  reclaimPolicy: Delete
  allowVolumeExpansion: true
  parameters:
    numberOfReplicas: "2"
    staleReplicaTimeout: "1440"
    fsType: "xfs"
    mkfsParams: "-f -b size=4096 -s size=4096"
    dataLocality: "best-effort"

---
# ë¶„ì„ ì›Œí¬ë¡œë“œìš© ìŠ¤í† ë¦¬ì§€
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: analytics-storage
  annotations:
    description: "Optimized for analytics workloads"
spec:
  provisioner: k8s-sigs.io/nfs-subdir-external-provisioner
  volumeBindingMode: Immediate
  reclaimPolicy: Delete
  allowVolumeExpansion: true
  parameters:
    server: "analytics-nfs.company.local"
    path: "/export/analytics"
    mountOptions: "nfsvers=4.1,hard,rsize=1048576,wsize=1048576,timeo=600,retrans=2"
```

## ğŸ“‹ ìŠ¤í† ë¦¬ì§€ í´ë˜ìŠ¤ ê´€ë¦¬ ë„êµ¬

### StorageClass ë¶„ì„ ìŠ¤í¬ë¦½íŠ¸

```bash
#!/bin/bash
# analyze-storage-classes.sh

echo "=== Storage Class Analysis ==="

# 1. í˜„ì¬ StorageClass ëª©ë¡
list_storage_classes() {
    echo "1. Available Storage Classes:"
    kubectl get storageclass -o custom-columns="NAME:.metadata.name,PROVISIONER:.provisioner,RECLAIM:.reclaimPolicy,BINDING:.volumeBindingMode,DEFAULT:.metadata.annotations.storageclass\.kubernetes\.io/is-default-class"
    echo
}

# 2. StorageClassë³„ PVC ì‚¬ìš©ëŸ‰
analyze_pvc_usage() {
    echo "2. PVC Usage by Storage Class:"
    
    # ê° StorageClassë³„ PVC í†µê³„
    kubectl get pvc --all-namespaces -o json | jq -r '
    .items[] | 
    [.metadata.namespace, .metadata.name, .spec.storageClassName // "default", .spec.resources.requests.storage, .status.phase] | 
    @tsv' | while read namespace name storage_class size phase; do
        echo "$storage_class,$namespace,$name,$size,$phase"
    done | sort | awk -F',' '
    {
        sc = $1
        size = $4
        phase = $5
        
        count[sc]++
        if (phase == "Bound") bound[sc]++
        
        # í¬ê¸° í•©ê³„ (ë‹¨ìˆœí™”ëœ ê³„ì‚°)
        if (size ~ /Gi$/) {
            gsub(/Gi$/, "", size)
            total_size[sc] += size
            unit[sc] = "Gi"
        } else if (size ~ /Mi$/) {
            gsub(/Mi$/, "", size)
            total_size[sc] += size / 1024
            unit[sc] = "Gi"
        }
    }
    END {
        printf "%-25s %8s %8s %12s\n", "STORAGE_CLASS", "TOTAL", "BOUND", "SIZE"
        printf "%-25s %8s %8s %12s\n", "-------------", "-----", "-----", "----"
        for (sc in count) {
            printf "%-25s %8d %8d %8.1f%s\n", sc, count[sc], bound[sc]+0, total_size[sc]+0, unit[sc]
        }
    }'
    echo
}

# 3. ì„±ëŠ¥ ê³„ì¸µ ë¶„ì„
analyze_performance_tiers() {
    echo "3. Performance Tier Analysis:"
    
    kubectl get storageclass -o json | jq -r '
    .items[] | 
    {
        name: .metadata.name,
        tier: .metadata.annotations["storage.company.com/tier"] // "unknown",
        performance: .metadata.annotations["storage.company.com/performance"] // "unknown",
        cost: .metadata.annotations["storage.company.com/cost"] // "unknown"
    } | 
    [.name, .tier, .performance, .cost] | 
    @tsv' | sort -k2 | column -t
    echo
}

# 4. ê¶Œì¥ì‚¬í•­ ìƒì„±
generate_recommendations() {
    echo "4. Recommendations:"
    
    # ê¸°ë³¸ StorageClass í™•ì¸
    default_sc=$(kubectl get storageclass -o json | jq -r '.items[] | select(.metadata.annotations["storageclass.kubernetes.io/is-default-class"] == "true") | .metadata.name')
    
    if [ -z "$default_sc" ]; then
        echo "âš ï¸  No default StorageClass found"
        echo "   Consider setting a default StorageClass for better user experience"
    else
        echo "âœ… Default StorageClass: $default_sc"
    fi
    
    # ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” StorageClass í™•ì¸
    unused_sc=$(comm -23 \
        <(kubectl get storageclass --no-headers | awk '{print $1}' | sort) \
        <(kubectl get pvc --all-namespaces --no-headers | awk '{print $4}' | sort -u))
    
    if [ -n "$unused_sc" ]; then
        echo "âš ï¸  Unused StorageClasses found:"
        echo "$unused_sc" | while read sc; do
            echo "   - $sc (consider removing if not needed)"
        done
    fi
    
    # ë³µì œ ìˆ˜ì¤€ì´ ë‚®ì€ ì¤‘ìš” ë°ì´í„° í™•ì¸
    echo
    echo "ğŸ’¡ Storage Optimization Tips:"
    echo "   - Use local storage for temporary/cache data"
    echo "   - Use network storage for shared data"
    echo "   - Set appropriate reclaim policies"
    echo "   - Enable volume expansion where needed"
}

# ì‹¤í–‰
list_storage_classes
analyze_pvc_usage
analyze_performance_tiers
generate_recommendations
```

### StorageClass ìƒì„± ë„êµ¬

```bash
#!/bin/bash
# create-storage-class.sh

STORAGE_CLASS_NAME=""
PROVISIONER=""
PERFORMANCE_TIER=""
ENVIRONMENT=""
WORKLOAD_TYPE=""

# ëŒ€í™”í˜• ì„¤ì •
interactive_setup() {
    echo "=== StorageClass Creation Wizard ==="
    
    # ê¸°ë³¸ ì •ë³´
    read -p "StorageClass name: " STORAGE_CLASS_NAME
    
    echo "Select provisioner:"
    echo "1) Longhorn (driver.longhorn.io)"
    echo "2) NFS (k8s-sigs.io/nfs-subdir-external-provisioner)"
    echo "3) Local (kubernetes.io/no-provisioner)"
    echo "4) Ceph RBD (rbd.csi.ceph.com)"
    read -p "Choice [1-4]: " provisioner_choice
    
    case $provisioner_choice in
        1) PROVISIONER="driver.longhorn.io" ;;
        2) PROVISIONER="k8s-sigs.io/nfs-subdir-external-provisioner" ;;
        3) PROVISIONER="kubernetes.io/no-provisioner" ;;
        4) PROVISIONER="rbd.csi.ceph.com" ;;
        *) echo "Invalid choice"; exit 1 ;;
    esac
    
    echo "Select performance tier:"
    echo "1) High (SSD, low latency)"
    echo "2) Standard (mixed, balanced)"
    echo "3) Bulk (HDD, high capacity)"
    read -p "Choice [1-3]: " tier_choice
    
    case $tier_choice in
        1) PERFORMANCE_TIER="high" ;;
        2) PERFORMANCE_TIER="standard" ;;
        3) PERFORMANCE_TIER="bulk" ;;
        *) echo "Invalid choice"; exit 1 ;;
    esac
    
    echo "Select target environment:"
    echo "1) Production"
    echo "2) Staging"
    echo "3) Development"
    read -p "Choice [1-3]: " env_choice
    
    case $env_choice in
        1) ENVIRONMENT="production" ;;
        2) ENVIRONMENT="staging" ;;
        3) ENVIRONMENT="development" ;;
        *) echo "Invalid choice"; exit 1 ;;
    esac
    
    echo "Select workload type:"
    echo "1) Database"
    echo "2) Web application"
    echo "3) Logging"
    echo "4) Backup"
    echo "5) General"
    read -p "Choice [1-5]: " workload_choice
    
    case $workload_choice in
        1) WORKLOAD_TYPE="database" ;;
        2) WORKLOAD_TYPE="webapp" ;;
        3) WORKLOAD_TYPE="logging" ;;
        4) WORKLOAD_TYPE="backup" ;;
        5) WORKLOAD_TYPE="general" ;;
        *) echo "Invalid choice"; exit 1 ;;
    esac
}

# StorageClass YAML ìƒì„±
generate_storage_class() {
    local filename="${STORAGE_CLASS_NAME}-storage-class.yaml"
    
    cat > "$filename" << EOF
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: $STORAGE_CLASS_NAME
  annotations:
    description: "$PERFORMANCE_TIER performance storage for $WORKLOAD_TYPE workloads in $ENVIRONMENT"
    storage.company.com/tier: "$PERFORMANCE_TIER"
    storage.company.com/environment: "$ENVIRONMENT"
    storage.company.com/workload: "$WORKLOAD_TYPE"
    storage.company.com/created-by: "storage-class-generator"
    storage.company.com/created-date: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
EOF

    # Provisionerë³„ ì„¤ì • ì¶”ê°€
    case $PROVISIONER in
        "driver.longhorn.io")
            generate_longhorn_config >> "$filename"
            ;;
        "k8s-sigs.io/nfs-subdir-external-provisioner")
            generate_nfs_config >> "$filename"
            ;;
        "kubernetes.io/no-provisioner")
            generate_local_config >> "$filename"
            ;;
        "rbd.csi.ceph.com")
            generate_ceph_config >> "$filename"
            ;;
    esac
    
    echo "StorageClass created: $filename"
}

generate_longhorn_config() {
    local replicas=3
    local reclaim="Delete"
    
    if [ "$ENVIRONMENT" = "production" ]; then
        reclaim="Retain"
    fi
    
    if [ "$PERFORMANCE_TIER" = "bulk" ]; then
        replicas=2
    fi
    
    cat << EOF
spec:
  provisioner: $PROVISIONER
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: $reclaim
  allowVolumeExpansion: true
  parameters:
    numberOfReplicas: "$replicas"
    staleReplicaTimeout: "2880"
    fromBackup: ""
    fsType: "ext4"
EOF

    if [ "$WORKLOAD_TYPE" = "database" ]; then
        echo "    dataLocality: \"strict-local\""
    fi
}

generate_nfs_config() {
    cat << EOF
spec:
  provisioner: $PROVISIONER
  volumeBindingMode: Immediate
  reclaimPolicy: Delete
  allowVolumeExpansion: true
  parameters:
    server: "nfs-server.company.local"
    path: "/export/$ENVIRONMENT/$WORKLOAD_TYPE"
    archiveOnDelete: "false"
EOF
}

generate_local_config() {
    cat << EOF
spec:
  provisioner: $PROVISIONER
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Delete
  allowVolumeExpansion: false
  parameters:
    type: "local"
    performance-tier: "$PERFORMANCE_TIER"
EOF
}

generate_ceph_config() {
    cat << EOF
spec:
  provisioner: $PROVISIONER
  volumeBindingMode: WaitForFirstConsumer
  reclaimPolicy: Retain
  allowVolumeExpansion: true
  parameters:
    clusterID: "ceph-cluster"
    pool: "$ENVIRONMENT-$WORKLOAD_TYPE"
    imageFormat: "2"
    imageFeatures: "layering,deep-flatten"
    
    csi.storage.k8s.io/provisioner-secret-name: "ceph-csi-rbd-provisioner"
    csi.storage.k8s.io/provisioner-secret-namespace: "ceph-csi-rbd"
EOF
}

# ì‹¤í–‰
interactive_setup
generate_storage_class

echo ""
echo "Review the generated StorageClass and apply with:"
echo "kubectl apply -f ${STORAGE_CLASS_NAME}-storage-class.yaml"
```

## ğŸ” ìŠ¤í† ë¦¬ì§€ í´ë˜ìŠ¤ ëª¨ë‹ˆí„°ë§

### ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§

```yaml
# storage-class-monitoring.yaml
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: storage-monitor-script
  namespace: monitoring
data:
  monitor.sh: |
    #!/bin/bash
    
    echo "=== Storage Class Usage Report ==="
    echo "Generated: $(date)"
    echo
    
    # PVC ìƒíƒœë³„ í†µê³„
    echo "PVC Status Summary:"
    kubectl get pvc --all-namespaces --no-headers | awk '{print $4}' | sort | uniq -c
    echo
    
    # StorageClassë³„ ìš©ëŸ‰ ì‚¬ìš©ëŸ‰
    echo "Capacity Usage by StorageClass:"
    kubectl get pvc --all-namespaces -o json | jq -r '
    .items[] | 
    select(.status.phase == "Bound") |
    {
        storageClass: (.spec.storageClassName // "default"),
        capacity: .status.capacity.storage
    } |
    "\(.storageClass),\(.capacity)"' | sort | awk -F',' '
    {
        sc = $1
        cap = $2
        
        if (cap ~ /Ti$/) {
            gsub(/Ti$/, "", cap)
            total[sc] += cap * 1024
        } else if (cap ~ /Gi$/) {
            gsub(/Gi$/, "", cap)
            total[sc] += cap
        } else if (cap ~ /Mi$/) {
            gsub(/Mi$/, "", cap)
            total[sc] += cap / 1024
        }
        count[sc]++
    }
    END {
        for (sc in total) {
            printf "%-30s: %6.1f GiB (%d PVCs)\n", sc, total[sc], count[sc]
        }
    }'

---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: storage-class-monitor
  namespace: monitoring
spec:
  schedule: "0 */6 * * *"  # 6ì‹œê°„ë§ˆë‹¤
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: monitor
            image: bitnami/kubectl:latest
            command: ["/bin/bash"]
            args: ["/scripts/monitor.sh"]
            volumeMounts:
            - name: script
              mountPath: /scripts
          volumes:
          - name: script
            configMap:
              name: storage-monitor-script
              defaultMode: 0755
          restartPolicy: OnFailure
```

## ğŸ“‹ ìŠ¤í† ë¦¬ì§€ í´ë˜ìŠ¤ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

### 1. ì„¤ê³„ ì›ì¹™

- **ëª©ì ë³„ ë¶„ë¥˜**: ì›Œí¬ë¡œë“œ íŠ¹ì„±ì— ë§ëŠ” ìŠ¤í† ë¦¬ì§€ í´ë˜ìŠ¤ ì œê³µ
- **ì„±ëŠ¥ ê³„ì¸µí™”**: ë¹„ìš©ê³¼ ì„±ëŠ¥ì˜ ê· í˜•ì„ ê³ ë ¤í•œ ê³„ì¸µ êµ¬ì¡°
- **í™˜ê²½ë³„ ê²©ë¦¬**: ê°œë°œ/ìŠ¤í…Œì´ì§•/ìš´ì˜ í™˜ê²½ë³„ ë³„ë„ í´ë˜ìŠ¤
- **í™•ì¥ì„± ê³ ë ¤**: ë¯¸ë˜ ìš”êµ¬ì‚¬í•­ì„ ê³ ë ¤í•œ ìœ ì—°í•œ ì„¤ê³„

### 2. ëª…ëª… ê·œì¹™

```bash
# ê¶Œì¥ ëª…ëª… ê·œì¹™
<ì„±ëŠ¥ê³„ì¸µ>-<ìš©ë„>-<í™˜ê²½>
ì˜ˆì‹œ:
- ssd-database-production
- hdd-logging-staging
- nvme-cache-development
```

### 3. ìš´ì˜ ê°€ì´ë“œë¼ì¸

- **ê¸°ë³¸ í´ë˜ìŠ¤ ì„¤ì •**: ì¼ë°˜ì ì¸ ìš©ë„ì˜ ê¸°ë³¸ StorageClass ì§€ì •
- **ì •ê¸° ê²€í† **: ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” í´ë˜ìŠ¤ì˜ ì •ê¸°ì  ê²€í†  ë° ì •ë¦¬
- **ëª¨ë‹ˆí„°ë§**: ìš©ëŸ‰ ì‚¬ìš©ëŸ‰ê³¼ ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì§€ì†ì  ëª¨ë‹ˆí„°ë§
- **ë¬¸ì„œí™”**: ê° í´ë˜ìŠ¤ì˜ ëª©ì ê³¼ ì œí•œì‚¬í•­ ëª…í™•íˆ ë¬¸ì„œí™”

### 4. ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

- **ì•”í˜¸í™”**: ë¯¼ê°í•œ ë°ì´í„°ë¥¼ ìœ„í•œ ì•”í˜¸í™” ìŠ¤í† ë¦¬ì§€ í´ë˜ìŠ¤
- **ì ‘ê·¼ ì œì–´**: RBACì„ í†µí•œ ìŠ¤í† ë¦¬ì§€ í´ë˜ìŠ¤ ì ‘ê·¼ ì œì–´
- **ê°ì‚¬**: ìŠ¤í† ë¦¬ì§€ ìƒì„±/ì‚­ì œì— ëŒ€í•œ ê°ì‚¬ ë¡œê·¸ ìœ ì§€

---

> ğŸ’¡ **ì‹¤ì „ ê²½í—˜**: ìŠ¤í† ë¦¬ì§€ í´ë˜ìŠ¤ ì„¤ê³„ëŠ” ë¹„ì¦ˆë‹ˆìŠ¤ ìš”êµ¬ì‚¬í•­ê³¼ ê¸°ìˆ ì  ì œì•½ì‚¬í•­ì˜ ê· í˜•ì ì„ ì°¾ëŠ” ê²ƒì´ í•µì‹¬ì…ë‹ˆë‹¤. ì²˜ìŒì—ëŠ” ê°„ë‹¨í•œ ë¶„ë¥˜ë¡œ ì‹œì‘í•´ì„œ ì‚¬ìš© íŒ¨í„´ì„ íŒŒì•…í•œ í›„ ì ì§„ì ìœ¼ë¡œ ì„¸ë¶„í™”í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. íŠ¹íˆ ì˜¨í”„ë ˜ í™˜ê²½ì—ì„œëŠ” í•˜ë“œì›¨ì–´ íŠ¹ì„±ì„ ì˜ ì´í•´í•˜ê³  ê·¸ì— ë§ëŠ” ìµœì í™”ë¥¼ ì ìš©í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

íƒœê·¸: #storageclass #storage #design #performance #optimization #onprem
